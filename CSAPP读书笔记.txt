第一章:
第二章:
第五章:优化程序性能
	5.7
	1>.编写高效程序必须做到以下几点:
		选择适当的算法和数据结构.
		编写出编译器能够有效优化以转换成高效执行的源代码.对此理解优化编译器的能力和局限性很重要.
		对运算量很大的计算,将一个任务分割成多个部分,利用多核处理器进行并行的计算.
	2>.循环展开技术:
		对每次循环只处理一个元素转化为每次循环处理多个元素,减少循环的次数.
	3>.消除低效循环,循环中不变的值放在循环体外只初始化或赋值一次.
	4>.减少过程调用,消除隐藏在循环体中函数里的冗余代码.
	5>.消除不必要的内存引用,例如在累加计算时将中间结果存放在指针指向的内存中,会增加内存读写次数,而该用临时变量而非指针保存中间结果,则只需一次读.
	6>.理解现代处理器??
	7>.循环展开.通过增加每次迭代计算的元素的数量减少循环的次数,来改进性能.循环展开提升性能的原因:
		1>.减少了不直接有助于程序结果的操作次数,比如循环索引计算和条件分支判断.
		2>.减少了整个计算中关键路径上的操作数量.

第六章:

第七章:链接
	7.7.2/7.12
	1>.链接:将各种代码和数据片段收集并组合成一个单一可执行文件的过程;由链接器自动执行的.
	2>.链接可以发生在编译时,可以发生在进程加载可执行文件时,也可以发生在运行时(动态加载).
	3>.链接器使得大型应用程序不必组织为一个巨大的源文件,可以将他们分解为更好管理的小模块,修改其中一个小模块只需重新编译它并重新链接所有目标文件即可.
		链接器的输入为一组可重定位目标文件和参数,输出为可执行目标文件.
	4>.大多数编译系统提供:预处理器,编译器,汇编器,链接器;对应编译的4个步骤.
	5>.链接器的两个主要任务:
		1>.符号解析:目标文件定义自己的符号(函数/全局变量/静态变量)并且引用其他符号;符号解析就是把链接器当前处理的目标文件中引用的其他符号与符号的定义关联起来.
		2>.重定位:链接器将符号定义与一个内存位置(虚拟地址)关联起来,然后修改所有对这个符号的引用,使得他们指向这个内存位置.
	6>.目标文件纯粹是字节块的集合,这些字节块包含程序代码,程序数据,引导链接器和加载器的数据结构.
		链接器将这些块连接起来,确定被连接块的运行时位置,修改代码和数据块中的各种位置.
	7>.目标文件有三种:
		可重定位目标文件:包含二进制代码和数据,可以在链接时与其他可重定位目标文件合并,创建可执行目标文件.
		可执行目标文件:就是可执行文件.
		共享目标文件:动态库.
		Windows使用可移植可执行格式(PE格式).
		Mac OS-X使用Mach-O格式.
		Linux/Unix使用可执行可链接格式(ELF格式).
	8>.ELF可重定位目标文件格式:
		ELF头:
			系统的字的大小
			字节序
			头大小.
			文件类型:可重定位/可执行/共享.
			机器类型:如x86-64
		.text节:	机器代码
		.rodata节:	只读数据
		.data节:	初始化的全局或静态变量,对应静态全局区.
		.bss节:		未初始化的全局或静态变量.
		.symtab节:	符号表,存放程序中定义和引用的函数和全局变量信息.和编译器的符号表不同,.syntab符号表中不包含局部变量条目.
		.rel.text节:记录.text节中的位置的列表,一般当链接器把这个目标文件与其他目标文件组合时,引用其他模块的函数或全局变量的条目都需修改,本地函数及局部变量则不需要修改.
		.rel.data节:被模块定义或引用的所有全局变量的位置的列表.
		.debug节:	定义的局部变量和类型,定义和引用的全局变量,源文件.只有-g选项编译时才会生成这个节.
		.line节:	源文件的行号与.text节中机器指令之间的映射,也只有-g选项编译时才会生成.
		.strtab节:	一个字符串表,内容是.symtab和.debug节中的符号表.
	9>.符号表包含模块定义的并能被其他模块引用的全局符号,其他模块定义的但在本模块引用的符号,以及只被本模块定义和引用的局部变量(static 全局变量,限制在本模块内).局部变量不在符号表中,因为他们是在运行时的栈中管理的.
	10>.编译器确保每个模块中的符号的唯一性,在符号解析时如果无法在任何模块匹配到一个符号的引用,就输出一条'未定义的引用'错误.
		多个目标文件之间可能存在同名的符号,Linux中使用如下3条规则处理多个模块间的重定义符号:
			1>.不允许多个同名的强符号.--链接器将产生一条重定义错误.
			2>.有一个强符号及多个弱符号同名,链接器选择强符号.
			3>.有多个弱符号同名,从弱符号中任意选择一个弱符号.
		函数和已初始化的全局变量是强符号,未初始化的全局变量是弱符号,强弱信息包含在符号表条目里.
	11>.将相关的目标文件打包成一个单独的文件,称为静态库.
		当链接器使用静态库构造一个可执行文件时,只复制静态库中被应用程序引用的目标文件.
		Linux中静态库以存档(archive)的格式把目标文件组织起来,有一个头部描述每个成员目标文件的大小和位置,以后缀.a标识.
	12>.在符号解析阶段,链接器从左到右扫描命令行中可重定位目标文件和静态库.
		在扫描中维护一个可重定位目标文件的集合E,未解析的符号集合U,以及已定义的符号集合D;这三个集合初始均为空.链接器依次判断输入的文件:
			如果是目标文件,则把它添加进E集合,根据该目标文件修改U和D.
			如果是静态库,则尝试匹配U集合中未解析的符号,如果静态库中某个目标文件定义了一个符号来解析U集合中的一个引用,则把该模块添加到E中并修改U和D.
		当链接器完成命令行上全部的输入文件的扫描后,U是非空的则输出一条错误,为空则合并和重定位E集合中的目标文件,构建可执行文件.
		因此定义符号的库出现在引用它的目标文件之前的话,引用不能被解析,导致链接失败.
	13>.重定位由两步组成:
			重定位节和符号定义:链接器将所有E集合中的目标模块的相同节合并为同一类型的新的聚合节,作为可执行文件的对应的节.然后将运行时内存地址赋给聚合节及节中的每个符号.这一步完成后程序中的每条指令和全局变量都有了唯一的运行时内存地址了.
			重定位节中的符号引用:链接器修改代码节和数据节中每个符号的引用,指向正确的运行时地址.
				通过节地址+条目偏移得到得到运行时地址.
	14>.动态链接:共享库是一个目标模块,在运行或加载时可以加载到任意内存地址,并和一个在内存中的程序链接起来,这个过程称为动态链接.
		对于共享库,所有引用该库的可执行文件共享这个.so文件中的加载到内存中的同一份代码和数据.
	15>.在创建可执行程序时,链接器复制一些共享库中的重定位和符号表信息,然后在程序加载时发现存在.interp节,根据.interp节中的动态链接器路径名加载和运行动态链接器,然后动态链接器通过如下步骤完成链接任务:
		重定位动态库的文本段和数据段到某个内存段.
		重定位进程中所有由动态库定义的符号的引用.
		最后动态链接器把控制权交给应用程序.
	16>.运行时加载和链接共享库
		void* dlopen(libpathname,flag)//函数用于运行时动态加载和链接共享库,返回共享库的句柄.
		void* dlsym(handle,"symname")//返回句柄对应共享库中的符号地址,不存在则返回NULL.
		int dlclose(handle)//卸载共享库.
		const char* dlerror()//用于获取以上三个函数的错误信息,没有错误则返回NULL.
	17>.共享库位置无关代码:加载而无需重定位的代码. -fpic选项指示GNU编译系统生成PIC代码.
		
	18>.Linux库打桩机制(Hook钩子)
		编译时打桩:
			1>.编写同名头文件及实现文件,并声明和实现自己版本的包装函数,定义打桩目标函数与自己版本的包装函数的宏定义.
			2>.编译链接时指定包含包装函数的同名头文件的路径,使预处理根据自己定义的头文件中的宏替换成自己的版本.
		链接时打桩:
			链接器提供了`--wrap,func`选项,指示链接器在链接时把符号`func`解析成__wrap_func,且把__real_func的引用解析成`func`.从而使程序中的调用替换成自己实现的__wrap_func,并且__wrap_func内部可以调用原始函数.
		运行时打桩:
			1>.为包装函数制作自己的动态库.
			2>.把该动态库的路径名添加到LD_PRELOAD环境变量,这样当加载和执行可执行程序时,需要解析未定义引用时,动态链接器会先搜索LD_PRELOAD中列出的库,然后才搜索其他库.
	19>.目标文件相关工具
		ar		:创建静态库,插入/删除/列出/提取静态库的成员.
		strings	:列出目标文件中所有可打印的字符串.
		nm		:列出目标文件符号表中的符号.
		size	:列出目标文件中节的名字和大小.
		readelf	:显式一个目标文件的完整结构.
		ldd		:列出可执行文件运行时需要的共享库.

第九章:虚拟内存
	9.6.2/9.6.3/9.7.1
    1>.虚拟内存是一种对主存的抽象，是硬件异常,硬件地址翻译,主存,磁盘文件和内核的完美交互,为每个进程提供一个大的,一致的和私有的地址空间;通过一个清晰的机制提供3个重要能力:
		1>.将主存看作是一个存储在磁盘上的地址空间的高速缓存,在主存中只保留活动区域,并根据需要在主存和磁盘之间传送数据,从而高效的使用主存.
		2>.为进程提供了一致的地址空间,简化了内存管理.
		3>.保护了进程的地址空间不被其他进程破坏.
	2>.早期PC及一些嵌入式微控制器及Cray超级计算器依然使用物理寻址,通过内存物理地址直接对内存进行读写.
		现代处理器使用虚拟寻址方式,在进程中虚拟内存空间中的变量都使用的是虚拟地址,cpu在访问变量时,先把虚拟地址送到MMU进行地址转换,MMU利用存放在主存中的页表将虚拟地址转换成物理地址,然后再使用物理地址对内存进行读写.
	3>.虚拟内存上的数据被分割为相同大小的块,这些块作为物理内存和虚拟内存之间的传输单元.虚拟内存的块成为虚拟页,物理内存的块成为物理页.
	4>.虚拟内存的页面有三种状态:
		1>.未分配的:虚拟内存系统还未分配(或还未创建)的页.未分配的页没有任何数据和他们相关联,也不占用磁盘空间,当然也不占用主存空间.
		2>.缓存的:已经被加载进物理内存中的已分配的页.占用磁盘空间和物理内存空间.
		3>.未缓存的:未被加载进物理内存中的已分配的页.只占用磁盘空间.
	5>.页表:用来判断一个虚拟页是否已被缓存在物理内存中,它表示虚拟页号与物理页号的映射关系,以及不命中时虚拟页在磁盘中的位置的映射关系,是页表条目(PTE)的数组.
	6>.页表条目(PTE)由有效位和地址字段组成.
		有效位为1时,地址字段非0则表示虚拟页对应的物理页在物理内存中的起始地址,地址字段为0时则表示虚拟页未被缓存在物理内存中(将产生缺页中断).
		有效位为0时,地址字段指向该虚拟页在磁盘上的起始位置.
	7>.页命中:CPU读写内存时,通过MMU在页表中查找页表条目,页表条目的有效位为1且地址字段非空,判断出读写内存缓存在物理内存中.
	8>.缺页(未命中):MMU根据页表条目的有效位和地址字段判断读写的内存地址不在物理内存中.
	9>.缺页中断:MMU判断缺页时触发缺页中断,由内核调度缺页异常处理程序,该程序根据缺页置换算法选择一个牺牲页,把磁盘中的虚拟页覆盖到物理内存中的牺牲页,然后更新页表条目,当缺页异常处理程序返回时将重启导致缺页的指令.
	10>.分配页面:当调用malloc时,内核在磁盘上分配虚拟块,更新页表条目指向这个虚拟块的起始地址.
		虚拟页分配完后并不立即加载进物理内存,当读写这个内存时由MMU触发缺页中断,由缺页异常处理程序载入物理内存.
	11>.虚拟内存作为内存管理的工具.
		简化链接:独立地址空间允许每个进程的内存映像使用相同的基本格式,而不用管代码和数据实际存放在物理内存的何处,由MMU进行虚拟寻址.
			例如代码段总是从虚拟地址0x400000开始,之后是对齐空白和数据段,从而简化了链接器的设计与实现,生成的可执行文件是独立于物理内存中代码和数据的实际位置的.
		简化加载:虚拟内存使得容易向内存中加载可执行文件和共享库等.
			例如linux加载器为可执行文件中的.text代码段和.data数据段加载进新创建的进程中,只需分配虚拟页并创建页表条目指向目标文件中的适当位置即可,而不用从磁盘到内存实际赋值任何数据(缺页异常处理程序会处理的).
		简化共享:当进程需要共享代码和数据时,创建页表条目指向物理内存中的物理页即可.
			例如进程必须调用相同的内核代码或C标准库中的函数,只需将不同进程中的适当虚拟页映射到相同的物理页面即可.
		简化内存分配:当请求分配堆内存时,内核分配指定大小对应的连续虚拟页,将他们映射到物理内存任意的对应个数的物理页面上,由于虚拟地址转换的存在,物理页可以随机分散在物理内存中.
	12>.虚拟内存作为内存保护的工具.
		内核不允许用户进程修改它自己的代码段,也不允许修改内核代码和数据结构,不允许他读写其他进程的私有内存,虚拟寻址机制和页表的存在提供一种天然的内存访问控制.通过为页表条目添加一些控制位来控制内存访问十分简单.
	13>.虚拟地址包含两部分:(虚拟/物理)页号和页偏移.物理地址类似.
	14>.虚拟内存区域:也叫作虚拟内存段(e.g. 代码段,堆段,栈段,常量段,静态全局段都是不同的内存区域),每个存在的虚拟页都保存在某个区域中.
	15>.内存映射:将一个虚拟内存区域与一个磁盘上的对象关联起来,以初始化这个虚拟内存区域的内容.
		内存映射可以映射到两种类型的对象的任意一种:
			linux文件系统中普通文件:
				比如可执行文件,文件区被分成页大小的片,每个片包含了一个虚拟页的初始内容,然后与某个虚拟内存区域中的页做映射.如果区域比文件区大,就用0来填充这个区域的余下部分.
			匿名文件:
				映射的匿名文件由内核创建,包含的全是二进制0.映射到匿名文件的区域中的页也叫作`请求二进制零的页`.
	16>.一旦一个虚拟页被初始化,它就在一个由内核维护的专门的交换文件之间换来换去,这个交换文件也叫作交换空间或交换区.交换区限制着进程能够分配的虚拟页的总数.
