1>.什么是操作系统？
	操作系统是管理计算机硬件和软件资源的计算机程序,提供一个计算机用户与计算机硬件系统之间的接口.

2>.什么是内核态和用户态？
	为避免操作系统和关键数据被用户程序破坏,将处理器的执行状态分为内核态和用户态.
	内核态:是操作系统管理程序执行时所处的状态,能够执行包含特权指令在内的一切指令,能够访问系统内所有的存储空间.
	用户态:是用户程序在用户空间下执行时处理器所处的状态,不能执行特权指令,只能访问用户地址空间;用户进程可以通过调用操作系统的系统调用进入内核态.

3>.从用户态切换到内核态的3种方式:***
	系统调用:用户进程通过系统调用申请操作系统提供的服务程序完成工作,系统调用本身是一种软中断.
	异常:当CPU在执行运行在用户态的程序时,发现了某些事件不可知的异常,此时会触发由当前运行进程切换到处理此异常的内核相关程序中,也就到了内核态,比文件损坏/如缺页异常.
	外部中断:当外围设备完成用户请求的操作之后,会向CPU发出相应的中断信号,这时CPU会暂停执行下一条将执行的指令;比如硬盘读写操作完成,系统会切换到硬盘读写的中断处理程序中执行后续操作等.

4>.并发和并行的区别?
	并发:宏观上看是同时进行的,微观上指令是交替运行的,并不能提升性能,只是提高了cpu的利用率,提升了时钟时间的利用率.
	并行:真正意义上的同时运行,同一时间片上执行了多条指令.

5>.什么是进程？什么是线程？***
	进程是:
		1>.可执行程序的一个运行中的实例.
		2>.是操作系统资源分配的基本单位,拥有独立的地址空间,一个进程无法访问另一个进程地址空间中的变量,进程间只能通过IPC进行通信.
		3>.是系统中独立运行的基本单位.
	进程上下文由程序正确运行所需的状态组成的,包括:
		内存中的程序的代码和数据
		栈
		通用/目的寄存器
		程序计数器
		环境变量
		打开文件描述符的集合
	进程一般由以下的部分组成：
		进程控制块PCB,是进程存在的唯一标志,包含进程标识符PID,进程当前状态,程序和数据地址,进程优先级,CPU现场保护区(用于进程切换),占有的资源清单等.
		程序段
		数据段
	线程是:
		1>.进程划分的任务,是进程的一条执行路径.
		2>.是CPU调度的基本单位,用于保证程序的实时性,实现进程内部的并发.
		3>.线程是操作系统可识别的最小执行和调度单位.每个线程都独自占用一个虚拟处理器:独自的寄存器组,指令计数器和处理器状态.
		4>.每个线程完成不同的任务,但是属于同一个进程的不同线程之间共享同一进程地址空间,打开的文件队列和其他内核资源.
	举个逻辑有点矛盾的例子:
		如果把铁轨比作一个cpu核心,不太恰当的把进程的地址空间比作火车头,进程则是一列火车,线程则是一节车厢.
		矛盾的点是一个铁轨上跑了多节车厢.

6>.线程和进程的区别 ***
	进程强调的是资源的管理,比如内存,虚拟内存;线程强调的是cpu的执行.

	空间和资源:进程在执行过程中拥有独立的地址空间,而线程共享进程的地址空间和资源.
	通信机制: 进程间使用IPC进行通信,进程中的多个线程共享进程地址空间,可以直接通信.
	同步机制: 进程间同步需要使用共享存储,在其上分配互斥锁等,还需设置进程共享属性健壮属性防止异常退出造成死锁,而线程间同步只需锁机制即可.
	调度切换: 进程创建及切换开销大;线程创建及切换开销小.
	归属:进程可以有多个线程,但至少有一个线程;而线程必须归属于一个进程,线程依赖于进程而存在.
	异常退出:进程异常退出不影响其他进程;线程异常退出将导致整个进程挂掉.
	进程适应于多核以及多机分布;线程只适用于多核.
	进程栈默认大小10MB,线程栈默认4KB.

7>.进程的基本操作
	fork:创建当前进程的副本,几乎完全与父进程相同,包括文件描述符,堆栈,代码区,常量区,静态全局区,但他们有不同的pid,以及子进程中只包含父进程中创建子进程的那个线程.
		fork之后子进程并不复制父进程的完全副本,而是采用写时复制技术,内核将进程空间的访问权限改为只读,当子进程和父进程其中之一修改某一区域时,内核才为修改区域的内存制作一个副本.
		fork之后父子进程的执行次序是不确定的,取决于内核调度算法.
	exec:加载可执行文件替换当前进程的正文段,数据段,堆段,栈段;新程序从main函数开始执行.
	wait/waitpid:用于父进程获取子进程的终止状态;一般在父进程接收到子进程结束信号SIGCHLD后调用.如果父进程不等待子进程将成为僵尸进程且操作系统无法释放对应资源.
		调用wait/waitpid时如果子进程都在运行,则阻塞;
		如果有子进程已终止等待父进程获取其终止状态,则取得该子进程的终止状态立即返回;
		如果进程没有任何子进程,也调用wait/waitpid则出错返回.
	exit:用于进程退出.

8>.简述写时复制机制？
	如果有多个进程只是读取它们自己的那部分资源的副本,那么复制是没必要的.每个进程只保存一个指向这个资源的指针就可以了,只要没有进程要去修改自己的"副本",就像独占那个资源从而就避免了复制带来的负担.
	当有进程要修改自己的那份资源,首先复制那份资源并提供给进程(复制过程对进程来说是透明的),然后该进程再修改复制后的独立资源了;其他进程仍然共享那份没有修改过的资源.
	写时复制的优点:
		如果进程一直不需要修改资源则不需要进行复制.惰性算法的好处就在于它们尽量推迟代价高昂的操作,直到必要的时刻才会去执行.
	在使用虚拟内存的情况下,写时复制是以页为基础进行的.所以只要进程不修改它全部的地址空间,那么就不必复制整个地址空间.在fork()调用结束后,父进程和子进程都相信它们有一个自己的地址空间,但实际上它共享父进程的原始页,接下来这些页又可以被其他的父进程或子进程共享.

9>.进程间通信的方法:***
	匿名管道:用在具有公共祖先的进程间.
	命名管道:用在同一主机中的进程间.
	XSI信号量
	XSI消息队列
	XSI共享存储
	pthread信号量
	网络套接字
	unix域套接字

10>.修改进程的文件描述符个数限制
	ulimit -n 10240 //只在当前终端生效
	/etc/security/limit.conf	//永久生效

11>.什么是信号?
	信号就是一条消息,它通知进程系统中发生了一个某种事件.Linux支持30种不同类型的信号. 每种信号类型都对应于某种系统事件.低层的硬件异常是由内核异常处理程序处理的,正常情况下,对用户进程而言是不可见的.信号提供了一种机制,通知用户进程发生了这些异常.
	信号产生的原因:
		内核检测到一个系统事件,比如除零错误或者子进程终止.
		kill命令或调用kill函数,显式地要求内核发送一个信号给目的进程.
		键盘快捷键ctrl+c等
	接收信号:当目的进程被内核强迫以某种方式对信号的发送做出反应时,它就接收了信号.进程可以忽略这个信号,终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号.

12>.进程调度的时机
	当前进程运行结束.
	进程由于某种原因阻塞.
	执行完系统调用等系统程序后返回用户进程.
	抢占式系统中,具有更高优先级的进程就绪时.
	分时系统中,分给当前进程的时间片用完.

13>.不能进行进程调度的情况
	在中断处理程序执行时.
	在操作系统的内核程序临界区内.
	其它需要完全屏蔽中断的原子操作过程中.

14>.进程的调度策略/算法
	主动式调度SCHED_OTHER:进程通过sleep或schedule函数主动让出cpu.
	先到先服务调度算法SCHED_FIFO:创建一个任务队列,一旦有新任务就加入这个队列,CPU完成一个任务后就从队列取任务.
	时间片轮转调度算法SCHED_RR:每个时间片依次执行一个任务,时间片结束后将该任务放回任务队列.
	短作业优先调度算法:针对较短的作业,优先调给CPU工作.
	优先级调度算法
	高响应比优先调度算法
	多级队列调度算法
	多级反馈队列调度算法:也按时间片轮转算法执行任务,设置n个队列,当第一个队列任务为空,才执行第二个队列,依次类推.如果在i队列的任务在该时间片执行后没有完成,即插入i+1号队列.

15>.进程调度策略的基本设计指标
	CPU利用率.
	系统吞吐率,即单位时间内CPU完成的作业的数量。
	响应时间.
	周转时间,是指作业从提交到完成的时间间隔.从每个作业的角度看,完成每个作业的时间也是很关键.
		平均周转时间
		带权周转时间
		平均带权周转时间

16>.进程的状态与状态转换
	进程在运行时有三种基本状态:就绪态/运行态和阻塞态.
	1.就绪(ready)态:进程具备运行条件,等待系统分配处理器以便运行的状态.当进程已分配到除CPU以外的所有必要资源后,只要再获得CPU,便可立即执行,进程这时的状态称为就绪状态.在一个系统中处于就绪状态的进程可能有多个,通常将它们排成一个队列,称为就绪队列.
	2.运行(running)态:进程占有处理器正在运行的状态.进程已获得CPU,其程序正在执行.在单处理机系统中,只有一个进程处于执行状态:在多处理机系统中,则有多个进程处于执行状态.
	3.阻塞(wait)态:又称等待态或睡眠态,指进程不具备运行条件,正在等待某个事件或I/O操作的完成的状态.
	各状态之间的转换:
		就绪→运行 处于就绪状态的进程,当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态.
		运行→就绪 处于执行状态的进程在其执行过程中,因分配给它的一个时间片已用完而不得不让出处理机,于是进程从执行状态转变成就绪状态.
		运行→阻塞 正在执行的进程因等待某种事件发生而无法继续执行时,便从执行状态变成阻塞状态.
		阻塞→就绪 处于阻塞状态的进程,若其等待的事件已经发生,于是进程由阻塞状态转变为就绪状态.

17>.简述孤儿进程与僵尸进程
	孤儿进程:父进程退出,子进程还在运行的这些子进程都是孤儿进程,孤儿进程将被init进程所收养,并由init进程对他们完成状态收集工作.
	僵尸进程:进程使用fork创建子进程,如果子进程退出,而父进程并没有调用wait/waitpid获取子进程的状态信息,那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程.
		避免僵死的进程:
			1>.父进程调用wait/waitpid获取子进程的状态.
			2>.kill父进程,使僵死的进程成为孤儿进程,从而被init进程收养后通过wait/waitpid获取退出状态使其退出.

18>.死锁是怎样产生的？
	死锁是指两个或两个以上进程在执行过程中,因争夺资源而造成的下相互等待的现象.
	产生死锁需要满足下面四个条件:
		互斥条件:进程对所分配到的资源不允许其他进程访问,若其他进程访问该资源,只能等待,直至占有该资源的进程使用完成后释放该资源.
		占有并等待条件:进程获得一定的资源后,又对其他资源发出请求,但是该资源可能被其他进程占有,此时请求阻塞,但该进程不会释放自己已经占有的资源.
		非抢占条件:进程已获得的资源,在未完成使用之前,不可被剥夺,只能在使用后自己释放.
		循环等待条件:进程发生死锁后,必然存在一个进程-资源之间的环形链.

19>.什么是虚拟内存***
	虚拟内存是一种对主存的抽象，是硬件异常,硬件地址翻译,主存,磁盘文件和内核的完美交互,为每个进程提供一个大的,一致的和私有的地址空间;通过一个清晰的机制提供3个重要能力:
		1>.将主存看作是一个存储在磁盘上的地址空间的高速缓存,在主存中只保留活动区域,并根据需要在主存和磁盘之间传送数据,从而高效的使用主存.
		2>.为进程提供了一致的地址空间,简化了内存管理.
		3>.保护了进程的地址空间不被其他进程破坏.

20>.虚拟内存的作用
	1>.虚拟内存作为缓存的工具
		虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组.
		虚拟内存利用DRAM缓存虚拟地址空间的页面.
	2>.虚拟内存作为内存管理的工具.操作系统为每个进程提供了一个独立的页表(虚拟地址空间).多个虚拟页面可以映射到同一个物理页面上.
		简化链接:独立的地址空间允许每个进程的内存映像使用相同的基本格式,而不管代码和数据实际存放在物理内存的何处.
			例如:linux系统中的每个进程都是用类似的内存格式,对于64位地址空间,代码段总是从虚拟地址0x400000开始.
		简化加载:虚拟内存还使得容易向内存中加载可执行文件和共享对象文件.
			要把目标文件中.text和.data节加载到一个新创建的进程中,Linux加载器为代码和数据段分配虚拟页VP,把他们标记为无效(未被缓存),将页表条目指向目标文件的起始位置.
		加载器从不在磁盘到内存实际复制任何数据,在每个页初次被引用时,虚拟内存系统会按照需要自动的调入数据页.
		简化共享:独立地址空间为OS提供了一个管理用户进程和操作系统自身之间共享的一致机制.
			一般:每个进程有各自私有的代码,数据,堆栈等,这样OS创建页表将虚拟页映射到不连续的物理页面.
			某些情况下,需要进程来共享代码和数据.例如每个进程调用相同的内核代码,或者C标准库函数,OS会把不同进程中适当的虚拟页面映射到相同的物理页面.
		简化内存分配:虚拟内存向用户提供一个简单的分配额外内存的机制.
			当一个运行在用户进程中的程序要求额外的堆空间时,OS分配一个适当k大小个连续的虚拟内存页面,并且将他们映射到物理内存中任意位置的k个任意物理页面,因此操作系统没有必要分配k个连续的物理内存页面,页面可以随机的分散在物理内存中.
	3>.虚拟内存作为内存保护的工具.不应该允许一个用户进程修改它的只读段,也不允许它修改任何内核代码和数据结构,不允许读写其他进程的私有内存,不允许修改任何与其他进程共享的虚拟页面.
			每次CPU生成一个地址时,MMU会读一个PTE,通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单.

21>.缺页置换及常见的缺页置换算法
	缺页置换
		当访问一个内存中不存在的页且内存已满时,需要从内存中调出一个页或将数据送至磁盘对换区,替换一个页,这种现象叫做缺页置换.
	先进先出(FIFO)算法：
		思路：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。
		实现：按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。
		特点：实现简单；性能较差，调出的页面可能是经常访问的。
	最近最少使用(LRU)算法:
		思路：置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。
		实现：缺页时，计算内存中每个逻辑页面的上一次访问时间，选择上一次使用到当前时间最长的页面
		特点：可能达到最优的效果，维护这样的访问链表开销比较大。
	最近最不常用算法(LFU)算法:
		思路：缺页时，置换访问次数最少的页面。
		实现：每个页面设置一个访问计数，访问页面时，访问计数加1，缺页时，置换计数最小的页面。
		特点：算法开销大，开始时频繁使用，但以后不使用的页面很难置换。

22>.优先级反转是什么?如何解决?
	在多进程共享资源,具有最高优先权的进程被低优先级进程阻塞时,反而使具有中优先级的进程先于高优先级的进程执行,这就是所谓的优先级反转.
	目前解决优先级反转,普遍使用的有2种方法:
		优先级继承, 将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级.当高优先级任务由于等待资源而被阻塞时,此时资源的拥有者的优先级将会自动被提升.
		优先级极限, 将申请某资源的任务的优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级.

23>.简述虚拟地址到物理地址转化过程
	虚拟地址由`虚拟页号`和`页偏移`组成;通过虚拟地址的页面号,先在快表中查询是否有该映射,查询不到则在页表中找到该页对应的物理地址.然后通过页物理地址+页偏移,得到真实的物理地址.

24>.简述页表
	页表用于保存虚拟地址中的虚拟页面号和物理页面号的映射关系.此外有些页的读写有限制,页表也通过其他存储位标记该页访问位,是否在内存中等等.

25>.简述多级页表
	多级页表用于减少内存的占用.以二级页表为例,虚拟地址被分为DIR,PAGE和offset三部分,通过顶级页表和DIR寻找到该二级页表的起始位置,再通过二级页表的起始位置和PAGE找到页物理地址,最后加上页偏移即可得到最终的物理地址.

26>.简述快表
	快表也称为页表高速缓存.其会存储一定数量的页表项,以此加快虚拟地址到物理地址的映射速度.

27>.简述MMU
	MMU即内存管理单元,该硬件负责处理虚拟地址到物理地址的转化工作;快表也存储在MMU上.

28>.同步异步与阻塞非阻塞的区别
		同步:完成之前不返回.
		异步:没完成也立即返回.
		阻塞:不能去干别的.
		非阻塞:可以去干点别的.
		同步和异步关注的是消息通知的机制,主动等待消息返回还是被动接受消息.
		阻塞和非阻塞关注的是程序在等待调用结果(消息,返回值)时的状态,阻塞等待还是立刻返回.

29>.IO模型有哪几种?
	1>.阻塞IO,套接字默认的模式.
		特点:能够及时返回数据无延迟,但需要等待.
	2>.非阻塞IO,通过fcntl或ioctl设置非阻塞模式.
		特点:不用等待可以执行其他任务,但需要sleep+询问IO状态增加了延迟和降低了吞吐量.
	3>.IO多路复用,select/poll/epoll方式.
		特点:能够同时处理多个连接且系统开销小,但并发量小的话比阻塞IO延迟高且无法保证请求与处理间的先后顺序.
	4>.信号驱动式IO(SIGIO).
		特点:对多个socket支持不太好,产生信号后不知道对应哪个socket.
	5>.异步IO(POSIX的aio_系列函数).
	posix异步与信号驱动式IO非常类似,区别在于:信号驱动式IO是由内核通知何时可以开始一个IO操作,而posix异步IO则是内核通知我们io操作何时完成.

30>.进程切换与线程切换区别
	进程切换:内核使用上下文切换的异常控制流来实现,内核为每个进程维护了一个上下文,上下文就是内核在切换进程时所需要的状态,由通用/浮点/状态寄存器,程序计数器,用户栈,内核栈和各种内核数据结构(页表,进程表),文件表等.首先保存当前进程上下文,然后恢复待恢复进程的上下文,最后转移控制权给新恢复的进程.
	线程切换:只需切换线程上下文,线程上下文包括用户栈,通用/浮点/状态寄存器,程序计数器等.也是先保存当前线程上下文,然后恢复待恢复线程的上下文,最后转移控制权给新恢复的线程.
	进程切换与线程切换最大的区别是对处理器缓存机制的损耗,一旦进程上下文切换,一是处理器中高速缓存的内存瞬间作废,二是虚拟地址转换器中的页表缓存也会被刷新,三是也可能会产生大量的缺页中断,进行物理页与虚拟页的交换产生大量磁盘IO,将导致一段时间内内存访问的低效,同一进程内的线程切换就不存在这种问题.

31>.linux系统的各类同步机制
	互斥锁
	读写锁
	自旋锁
	条件变量
	信号量
	屏障
	原子操作:
		使用总线锁保证原子性:使用CPU提供的LOCK信号,当处理器在总线上输出此信号时,其他处理器的请求将被阻塞,在x86平台上,CPU提供了在指令执行期间对总线加锁的手段.CPU芯片上有一条引线#HLOCK pin,如果汇编语言的程序中在一条指令前面加上前缀"LOCK",经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低,持续到这条指令结束时放开,从而把总线锁住,这样同一总线上别的CPU就暂时不能通过总线访问内存了,保证了这条指令在多处理器环境中的.
		使用缓存锁保证原子性:如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定,当它执行锁操作回写内存时,处理器不在总线上声言LOCK＃信号,而是修改内部的内存地址,并允许它的缓存一致性机制来保证操作的原子性,因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据,当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效.

32>.linux系统的各类异步机制
	信号机制

33>.exit()与_exit()的区别
	exit()会先调用atexit()注册的退出回调函数,然后把文件缓冲区的内容写回文件,之后调用_exit()函数清理内存和内核中的数据结构.

34>.linux的内存管理机制
	虚拟内存机制,参见CSAPP.

35>.linux的任务调度机制
	
36>.linux设置开机自启动
	1>.在/etc/rc.local中添加启动命令.
	2>.把启动脚本放到/etc/init.d/目录中.
	3>.使用systemd工具管理开启自启动.
		在/usr/lib/systemd/system或/etc/systemd/system目录下创建配置文件*.service
		sudo systemctl start *.service添加并启动服务
		sudo systemctl enable *.service设置服务自启动

37>.ipcs ipcrm top vmstat
	netstat:查看系统中打开的socket相关信息
	lsof:类似netstat,它打印的还有打开的文件.
	tcpdump:抓包工具.
	ipcs:查看系统中正在使用的3种XSI IPC的状态和信息.
	ipcrm:删除系统中的XSI IPC.
	iostat:查看磁盘读写情况.
	vmstat:查看系统的cpu,内存,页交换,磁盘读写,中断及上下文切换次数等信息.
	top:查看进程的cpu内存IO等情况
	free:查看系统中内存的已用,未用及交换区的使用情况.
	ps:查看进程信息.
	uptime:查看服务器运行时长,用户登录及平均cpu负载情况.
	iptraf:监控网络实时流量,可根据各个session,网卡,协议进行监控.