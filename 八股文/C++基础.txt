2>.C++内存模型
	代码区:存放二进制代码,由exec加载可执行文件映射进内存.
	常量区:存放常量
	静态全局区:分为初始化区和未初始化区,初始化区由可执行文件中已初始化的全局静态变量加载进内存并初始化,未初始化区存放的变量在可执行文件中只保存了变量名,类型,长度等信息.
	堆:在程序运行时由程序员动态申请和释放.
	栈:由编译期管理分配和回收,存放局部变量,函数参数,线程调用栈帧.
3>.函数参数传递方式
	传值:通过拷贝构造函数创建一个新对象,传递的是实参对象的副本;函数内部对形参的操作并不会影响到外部的实参.
	传指针:传的是所指对象的地址,函数内通过地址对对象进行访问,避免对象的拷贝. 函数内对指针所指对象进行修改,函数外通过指针访问同一个时看到是变化的.
	传引用:只是变量的别名,并不分配单独的内存,与实参共享同一内存空间. 实际是把引用对象的地址放在了开辟的栈空间中, 在调用函数内部对形参的访问都会处理成间接寻址,访问的是父函数中的实参.
4>.关键字
	●const关键字
		修饰基本数据类型时,表明这是一个常量,编译时会进行检查不能被修改.
		修饰指针时,技巧在于看关键字const右边是类型,则值是常量; const右边是指针变量,则指针本身是常量.
		修饰引用时,表明是常引用,不能被修改和赋值.
		修饰函数参数时,在函数内进行常量化,保护变量不被修改.
		修饰类成员变量时,表明是类的常量属性,只能初始化不能被赋值.只能在构造函数的初始化列表中初始化.
		修饰类成员函数时,表明函数是常函数,防止成员函数修改对象的内容.const关键字与static无法同时使用,因为static修饰后与具体某个对象无关了.
			常量对象只能调用const成员函数,不能调用non-const成员函数.因为如果调用non-const成员函数时,隐式的this指针需要指向是const对象.
			non-const对象可以调用const成员和non-const成员函数.
			实在想在const成员函数中修改某个变量,可以使用mutable修饰这个变量.
	●volatile关键字
		volatile的特性:
			指示编译不要对修饰的变量进行优化,每次读取都从内存中读而不是寄存器,但不具有原子性.
			volatile和const关键字可以同时使用.
		volatile的使用场景:
			当多个线程都会用到某一变量,且该变量的值随时可能发生改变.
			中断服务程序中访问的变量或并行设备的硬件寄存器的变量.
	●extern关键字:
		修饰变量时表明此变量/函数是在别处定义的,要在此处引用.不使用include的方式使用其他文件中的变量而使用extern是因为可以加快编译速度.
		extern "C"指示链接器以C函数规范来链接.主要原因是C＋＋与C程序编译完成后在目标代码中命名规则不同,用此来解决名字匹配的问题.
	●define与const的区别
		define仅仅是编译预处理展开,没有类型检查,递归展开易出错.编译会保留多份数据,展开的代码也是多份,没有作用域的限制.
		const是在编译期间处理的,有类型检查,运行时在内存中有且只有一份数据.
	●static关键字
		修饰局部变量:有默认值0且只执行一次,运行一开始就开辟了内存,存放在静态全局区.
		修饰全局变量或函数:使之失去全局可见性.
		修饰成员变量:所有类对象共享此成员,存储在静态全局区
		修饰成员函数:没有隐藏的this指针,不依赖于对象通过类名修饰即可调用.
		保持变量内容的持久.
		默认初始化为0,因为静态全局区所有字节默认值都为0x00.
5>.全局变量与静态变量
	全局变量既可以在本文件中被访问,也可以在同一工程中的其他源文件被访问(添加extern进行声明即可).
	静态变量只能在本文件可见,对于用static修饰的全局变量,其作用域也变成了本编译单元.静态全局变量只能初始化一次.
6>.C和C++的区别
	不严谨的来讲C++是C的超集,严格来讲C++涵盖C的绝大部分,C++比C多出一大部分.
	C独有的部分:
	C++独有的部分:面向对象,泛型,元编程,STL
	STL标准库
7>.C++中各种常量以及常量存放位置***
	对于局部常量，存放在栈区;
	对于全局常量，编译期一般不分配内存，放在符号表中以提高访问效率;
	字面值常量，比如字符串，放在常量区.
8>.C++重载,重写,重定义的区别***
	重写/覆盖:子类重新实现父类中的虚函数.在父类中是private但子类中可以改为public的.
	重定义/隐藏:子类重新实现父类中的非虚函数,只要同名函数不管参数列表是否相同都会隐藏基类中的非虚函数.
	重载:函数名相同,而参数列表的不同,根据参数列表决定调用哪个函数.注意重载不关心返回值类型,只关心参数.
	区别:
		重载发生在同一个类的内部,重写发生在基类派生类的虚函数之间,隐藏发生在基类派生类的非虚函数之间.
		重载参数列表必须不同,重写返回值参数列表必须相同,隐藏函数名必须相同.
9>.如何理解C++是面向对象编程
	首先面向过程是以种以函数为中心编写软件的方法,数据和处理过程是分离的,可能会导致问题.
	面向过程,以创建和使用对象为中心.把数据和处理过程组成一个整体,易于维护.而且通过不同的保护级别来保护数据.
10>.sizeof和strlen的区别
	sizeof是C++运算符,strlen是函数
	strlen测量的是字符串以\0结束的实际长度(不包含结束符),sizeof测量的是字符数组的内存分配大小.
	sizeof的参数可以是类型,而strlen只能是字符数组.
11>.define和typedef的区别
	define是编译预处理宏,typedef是C++关键字.
	define发生在编译预处理时不做类型检查,typedef发生在编译时有类型检查,但不能在函数定义里使用typedef.
	define没有作用域限制,typedef有作用域限制.
	define与typedef处理指针类型时完全不同.
12>.new/delete与malloc/free的区别***
	new会调用构造函数,malloc只是申请指定大小的内存,不会调用构造函数进行初始化.
	new无需指定申请的内存大小根据类型自动确定,malloc须指定申请额内存大小.
	new分配失败时抛出bad_alloc异常,malloc分配失败时返回空指针.
	new/delete  malloc/free必须配对使用.
13>.c++类型转换
	static_cast:相近类型之间的转换
	const_cast:去掉const属性,使之可被修改
	dynamic_cast:基类派生类之间的类型转换,有编译器做安全检查.
	reinterpret_cast:重新解释类型,在比特级别上进行转换,常用的就是在函数指针类型之间进行转换.
	C风格的强制转换有2个缺点:
		通过构造函数进行的隐式类型转换在某些情况下可能会出问题，比如数据精度丢失.
		显式类型转换将所有情况混合在一起，转换的可视性比较差.
14>.RTTI 运行时类型识别
	RTTI的用途:
		希望调用类成员的正确版本,而派生对象可能包含不是继承而来的成员,此时需要知道具体类型.
		可能会出于调试目的，跟踪生成的对象的类型.
	RTTI的使用:
		typeid关键字,返回其表达式或类型名的实际类型.
		dynamic_cast运算符,将使用一个指向基类的指针来生成一个指向派生类的指针；否则，该运算符返回0
15>.为什么用成员初始化列表会快一些?
	因为不放在初始化列表,编译器自动添加一个默认构造函数的调用动作,而自己添加的所谓`初始化`,实则是赋值操作,调用赋值操作符进行赋值,所以多了一步赋值操作.
16>.编译器会给一个`空类`自动生成哪些函数？
	默认构造
	默认析构
	拷贝构造
	赋值操作符
	non-const取址运算符
	const取址运算符
	注意:
		上边说的是空类,只有当一个类没有任何自定义的拷贝控制成员,且所有数据成员都能移动构造或移动赋值时,编译器才会为它合成移动构造函数或移动赋值运算符.

17>.指针和引用的区别***
	指针是一个地址可以改变指向的内存,引用只是一个别名,一旦绑定到对象上不能改变引用其他对象.
	指针的值是所指向的内存的地址,在编译时，则是将“指针变量名-指针变量的地址”添加到符号表中，所以说，指针所指的内容是可以改变的,有 const 和非 const 区别,可以为空,sizeof 指针得到的是指针类型的大小. 指针需要被解引用后才可以对对象进行操作.
	作为参数时也不同,传指针的实质是传值,传递的值是指针的地址; 传引用的实质是传地址,传递的是变量的地址.
18>.野指针和悬空指针
		野指针:没有被初始化过的指针,依编译器不同指向未知区域.
		悬空指针:所指对象已经被销毁,但没有被置空.
	避免野指针悬空指针:
		1>.养成初始化和销毁置空习惯.
		2>.使用智能指针,即使是不需要shared_ptr这种选手, 也可以使用unique_ptr不会带来额外的性能损耗.
19>.简述函数指针
	类似普通的变量指针,函数指针指向函数的入口地址,通过该指针对指向的函数进行调用. 可以通过函数指针把函数地址传递给其他对象,作为回调函数.
20>.堆与栈的区别***
	管理方式:栈由编译期分配和回收,堆由程序员通过new/delete申请和回收,容易内存泄露.
	空间大小:栈大小有限制,堆的大小没有限制.
	碎片问题:栈不会产生内存碎片,堆会产生内存.
		在函数调用的时候,首先入栈的是函数的下一条可执行指令的地址,然后是函数的各个参数,当函数调用结束时局部变量先出栈,然后是参数,最后是函数地址,程序由该点继续运行,所以不会产生碎片.
		堆是不连续的空间,系统中维护一个空闲链表,当申请内存时遍历空闲链表找到第一个大于等于申请大小的内存分配给程序, 在分配时会在空间头部写入内存大小方便delete回收,当然如果有剩余的,也会将剩余的插入到空闲链表中,这也是产生内存碎片的原因.
	生长方向:堆生长方向是向上的,也就是向着内存地址增加的方向;栈的生长方向是向下的,向着内存地址减小的方向增长.
	分配效率:栈的分配有专门的寄存器存放地址和压栈出栈指令,效率高;堆由C++函数分配回收,内部有申请查找空闲内存等逻辑,效率低.
21>.计算类的大小
	计算原则:
		1>.遵循内存的对齐原则.
		2>.大小与普通成员变量有关,与成员函数和静态成员无关.
		3>.是否有虚函数对类的大小有影响,是因为虚表指针.
		4>.虚继承对类的大小有影响,因为有虚基表指针.
		5>.空类是一个特殊情况大小为1,为了保证不同对象的地址不同,空类也需要占用存储空间.
	空类:1字节
	有一个静态数据成员的类:1字节
	有一个int成员变量的类:4字节
	分别有一个静态和普通int变量的类的类4字节.
	有一个虚函数的类:4字节(虚表指针).
22>.C++类对象的内存分布
	●一个类对象至少要占用1字节的内存空间.
	●类对象所占用的存储空间只是该对象的普通数据成员(包含虚表指针和虚基类指针)占用的存储空间,而不包含函数代码所占的存储空间.
	●普通数据成员按照声明顺序布局.
	●静态数据成员不占用对象内的存储空间,而是存储在静态全局段.
	●类的所有成员函数都被放在代码段,所有类对象通过this指针共用非静态成员函数,且没有对象时也可以使用静态成员函数.
	●内存模型:
		无继承:
			普通数据成员按照声明次序存放.
			如果存在虚函数则首先是一个vptr,其次才是普通数据成员.
		单继承:
			基类普通数据成员,其次是派生类的普通数据成员.
			如果基类有虚函数,则首先是基类的vptr,其次是基类普通数据成员,最后是派生类数据成员;
			派生类重写的虚函数或新加的虚函数都覆盖/添加到基类vptr指向的虚函数表中.
		多继承:
			第一个基类的vptr及成员数据,第二个基类的vptr及成员数据,最后是派生类普通数据成员.
			基类拥有各自的虚函数表,派生类的虚函数放入到第一个基类的虚函数表.
		菱形继承:
			对象由中间类的vptr及成员数据,虚基类的vptr及成员数据顺序构成.
			虚基类和中间类都有vptr,但派生类没有vptr,派生类的虚函数放在第一个中间类的虚函数表中.
		虚继承:
			派生类的vptr及成员数据,基类的vptr及成员数据顺序构成.
			基类和派生类都有的vptr.
23>.面向对象的三大特征:
	封装:把客观事物抽象成类,通过成员函数操作成员属性;减少耦合,隐藏实现细节易于使用,通过不同保护级别控制外部的访问.
	继承:子类继承父类的特征和行为,子类有父类的非private成员变量和函数,并可以在父类的基础上进行添加,修改或覆盖,以复用以前的代码.
		在菱形继承结构中,需要使用虚继承,避免多份公共基类的副本.在GCC中虚继承派生类大小为:派生类数据成员对齐大小+虚基类大小+指向基类虚函数表指针的大小,注意没有自己的虚表指针了.
	多态:不同的类实现相同的接口,在运行时对不同的对象调用不同的函数,呈现不同的表现方式.
24>.多态的实现
	多态分为静态多态和动态多态.
	静态多态:函数的重载,根据不同的函数参数列表,在编译时确定调用哪个同名不同参数的函数.
	动态多态:通过子类实现父类的虚函数,在运行时根据指针指向的实际对象调用对应子类的实现.
25>.虚函数表和虚函数指针
	当一个类中包含虚函数时,编译器会为该类生成一个虚函数表,保存该类中的虚函数地址;虚函数表是全局共享的元素,即全局仅有一个.
	gcc中虚函数表存放在可执行文件的只读数据段.rodata中;微软的编译器将虚函数表存放在可执行文件的常量段中.
	当创建对象时编译器检查该类有虚函数,为该对象生成一个虚表指针指向该类的虚函数表,虚表指针的初始化是在构造函数中由编译器自动完成的.
	后续如果用一个基类指针指向派生类对象,在调用虚函数时会根该对象的虚表指针指向的虚函数表中查找虚函数地址,以此实现多态.
	子类的虚函数表包含从父类继承来的虚函数及子类重写和新增的虚函数地址.
	多重继承时,每个含有虚函数的基类在派生类中都有对应的虚表指针,用于derver->Base::func()这种指定某个父类虚函数的调用.
26>.编译器如何处理虚函数表
	对于派生类,编译器建立虚函数表有3个步骤:
		1>.拷贝基类虚函数表,多重继承就所有有虚函数的基类的虚函数表.
		2>.查看派生类是否重写了基类中的虚函数,如果有替换成自己重写的虚函数地址.
		3>.查看派生类是否有新加的虚函数,如果有追加到虚函数表中.
27>.析构函数为什么要写成虚函数?
	如果基类指针指向派生类对象,而基类的析构函数是non-virtual函数,则在释放对象时不会动态绑定,调用的是基类的析构函数,那么仅仅释放的是派生类对象的基类部分,造成内存泄露.
	如果析构函数是虚函数,那么在释放指向派生类对象的基类指针时,将动态绑定到子类虚析构函数,能够正确释放子类部分和基类部分的资源.
28>.构造函数为什么不定义为虚函数?
	虚函数的作用在于通过基类的指针或引用来调用子类的哪个成员函数,构造函数用于构造对象,声明成虚函数没有意义.
	再就是虚函数的调用是通过对象中的续表指针查找虚函数表来确定函数地址,在构造函数构造对象时,对象还不存在,无法通过虚表指针查找虚函数地址,有冲突.
29>.构造函数或析构函数中调用虚函数会怎样?
	不应在构造/析构函数中调用虚函数,这样的调用并不会带来想要的效果.
	派生类中重写虚函数,当创建一个派生类对象时,首先调用基类构造函数构造基类部分,此时派生类的部分还没有初始化,编译器会认为这是一个基类类型的对象,调用基类中的虚函数,并没有按照我们的预期动态绑定到子类虚函数上.
	析构函数也一样.
30>.析构函数的作用
	当对象超出作用域时,自动调用释放资源.或在堆上申请的内存调用delete时自动调用析构函数.
31>.构造函数和析构函数的调用顺序
	构造函数调用顺序:
		首先是基类构造函数,按照派生表中的顺序调用.
		然后调用派生类对象里成员的构造函数,按声明顺序调用.
		最后调用派生类构造函数
	析构函数调用顺序:
		首先调用派生类析构函数.
		然后调用派生类里成员对象的析构函数.
		最后调用基类的析构函数.
32>.深拷贝和浅拷贝的区别
	浅拷贝:在拷贝一个对象时,一一复制其数据成员,如果有指针成员复制的是指针的值,两个对象中的指针指向的是同一块内存.
	深拷贝:拷贝对象时也是一一复制数据成员,如果有指针则重新申请一块新的内存,把被拷贝对象中的指针成员指向的内存内容复制到新对象中新申请的内存上.
	浅拷贝时对一个对象中的指针指向的内容进行修改,会影响另一个对象.也可能重复释放带来悬空指针问题.
33>.调用拷贝构造函数的情况
	1>.以值传递的方式传给函数.
	2>.以值的方式从函数返回.
	3>.用一个对象初始化另一个对象.
34>.为什么拷贝构造函数的参数必需是引用传递?
	因为使用传值的话会调用拷贝构造函数构造实参,陷入拷贝构造调用的无限循环,所以拷贝构造的参数必须是引用类型.
35>.如何避免拷贝?
	将拷贝构造及赋值操作符声明为private不可行,因为友元函数和成员函数依旧可以使用他们.
	使用新的关键字delete作为函数声明的修饰后缀,明确拒绝编译器生成默认拷贝构造和赋值操作符.
36>.如何禁止一个类被实例化?
	类中定义一个纯虚函数.
	私有构造函数不行,因为单例模式依然可以自己构造自己.
37>.实例化一个对象需要哪几个阶段
	1>.分配空间(栈或堆).
	2>.基类构造函数构造基类部分.
	3>.虚表指针赋值.
	4>.自己的构造函数.
38>.std::move的实现原理
	利用模板接收各类型参数,然后通过static_cast进行强制类型转换.
39>.C++11中的nullptr比NULL优势
	nullptr有类型,专指空指针,编译器有类型检查,而NULL本质上是值为0的宏.
	在以int为参数的函数调用中可以传NULL而不会报错.
40>.内存对齐的规则
	1>.结构体中第一个成员位于偏移为0的位置,之后的数据成员的偏移量必须是 min(#pragma pack(), 数据成员本身长度)的倍数.
	2>.在所有的数据成员完成各自对齐后,结构体/联合本身也要对齐, 整体长度是 min(#pragma pack(), 最长的数据成员的长度)的倍数.
	3>.结构体中有其他结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.
	4>.内存对齐的填充位的值是随机的.
	对齐原因见Effective c++读书笔记
	#pragma pack(n)
		n为0时,表示使用默认对齐
		n为1时,不进行内存对齐,因为是按1字节对齐.
41>.能否用memcmp对两个结构体内存进行比较?
	不可以,因为memcmp是逐个字节对比的,当结构体字节对齐时填充部分值是随机的,所以比较的结果是不正确的.
42>.迭代器产生原因
	迭代器把不同类的访问逻辑抽象出来,使得不用暴露容器内部的结构而能够访问容器中的元素.
43>.段错误产生的原因
	1>.访问不存在的内存地址.
	2>.访问系统保护的内存地址.
	3>.访问只读的内存地址.
	4>.栈溢出.
44>.什么是内存泄漏?如何检测内存泄漏?
	申请了一块内存,使用完毕后没有释放.表现就是占用内存随着运行时间而增长,最终把内存消耗殆尽.
	检测内存泄漏:
		1>.定期肉眼观测内存占用情况,只能检测出比较严重的内存泄漏.
		2>.valgrind的Memcheck工具,使用valgrind启动目标进程,然后执行可能内存泄漏的逻辑一段时间,结束valgrind后会输出内存分析结果.不止内存泄漏,比如越界,未初始化等,悬空指针等.
			Memcheck 能够检测出内存问题,关键在于其建立了两个全局表:
				Valid-Value表:对于进程整个地址空间中的每个字节,都有与之对应的8个bits;对于CPU的每个寄存器也有1个与之对应的bit向量.这些bits负责记录该字节或者寄存器值是否具有有效的/已初始化的值.
				Valid-Address表:对于进程整个地址空间中的每个字节,还有与之对应的1个bit,负责记录该地址是否能够被读写.
			检测原理:
				当要读写内存中某个字节时,首先检查这个字节对应的Valid-Address表中对应的bit.如果该bit显示是无效位置则报告读写错误.
				内核类似于1个虚拟的CPU环境,这样当内存中的某个字节被加载到真实的CPU中时,该字节在Valid-Value表对应的bits也被加载到虚拟的CPU环境中.一旦寄存器中的值被用来产生内存地址或该值能够影响程序输出,则Memcheck会检查Valid-Value表对应的bits,如果该值尚未初始化则会报告使用未初始化内存错误.
		3>.mtrace工具,为new/delete malloc/free安装hook函数,监视内存的申请与释放.使用方式在项目中包含mcheck.h头文件并修改环境变量,程序运行后会输出内存申请与释放日志.
	如何避免内存泄漏?
		遵循RAII机制.
		使用智能指针,担心智能指针比裸指针有额外的性能开销? unique_ptr了解一下. unique_ptr不适用的场景也不用在乎shared_ptr那点开销了.

45>.源文件怎么变成一个可执行文件的? / C++程序编译过程
	编译过程分为四个子过程:预处理,编译,汇编,链接.
		1>.预处理:将#开头的指令展开,源文件经过编译预处理得到.i文件;i文件其实就是把include头文件内容的插入,删除#define并替换宏,代码过滤.
		2>.编译:对预处理后的.i文件进行词法分析,语法分析,语义分析,以及优化后产生相应的.s汇编文件.
		3>.汇编:把.s汇编文件中的汇编代码翻译成目标机器指令生成.o或.obj目标文件.
		4>.链接:把每个独立.o目标文件按照它们的要求将它们组装起来(比如一个cpp调用了另一个cpp或库中的函数),产生.out可执行文件;链接主要解决的是源代码之间的相互依赖问题.
			1>.静态链接:将汇编生成的目标文件.o与引用到的库中的代码一起链接打包到可执行文件中.
			2>.动态链接:在程序编译时并不会把库中的机器码拷贝到可执行程序中,而只是记录了引用的库名及库中函数的相对地址,而是在程序运行时动态装载及加入地址偏移量.
46>.动态编译与静态编译
	静态编译:在编译可执行文件时,把用到的静态库中的部分提取出来,添加到可执行文件中,使可执行文件在运行时不需要依赖于动态链接库.
	动态编译:在编译可执行文件时,把使用的库的名字和内部变量及函数的相对地址记入可执行文件中;在进程载入可执行文件时,由动态链接器读取信息,根据地址偏移量动态绑定使用的库中的变量和函数地址.
47>.动态库与静态库***
	静态库:可以简单的看成是一组目标文件的集合,即把一到多个目标文件使用`ar`压缩程序打包压缩后形成的文件.格式为lib+'名字'+.a
		静态库:模块更新需要重新编译链接,可执行文件体积大,但没有外部依赖,进程启动更快没有动态连接器动态链接步骤.
	动态库:在运行时才去链接动态库的代码,多个程序共享动态库的代码.可执行文件仅仅包含它用到的动态库名字及库中的函数入口地址表,而不是用到的函数的机器码.
		动态库的使用方法:
			1>.把动态库拷贝到/usr/lib和/lib路径下.
			2>.在环境变量LD_LIBRARY_PATH中加上动态库所在路径.
			3>.把库路径添加到/etc/ld.so.conf文件中,然后ldconfig刷新.
	使用nm来查看库中函数.
	ldd查看可执行程序的库依赖.
	在编译链接可执行程序时,同时指定动态库和静态库,哪个在前边使用哪种链接方式及对应的库.
48>.动态链接和静态链接
	静态链接:源文件经过预处理,编译,汇编后产生目标文件,在链接时检查目标文件的调用依赖关系,将依赖的库中的代码都添加到可执行文件中,运行时不再需要静态库中的机器码.
	动态链接:在进程启动加载可执行文件时,由动态链接器动态链接到共享库.
49>.动态联编与静态联编
	其实也就是函数的静态绑定(重载)和动态绑定(多态虚函数),名字取得真吓人.
50>.C++类之间有哪几种关系?***
	1>.继承:一个类(子类)继承另外一个类(基类)的功能,并增加它自己的新功能的能力; 实现单箭头指向基类
	2>.关联:一个类作为另一个类成员函数的参数; 用虚线表示
	3>.聚合:整体与部分的关系. 部分与整体的生存期无关,且可以改变部分所属的聚合对象; 比如指针成员. 空心菱形和实线表示
	4>.组合:也表示整体和部分的关系. 但组合中部分和整体有相同的生存期;比如普通成员变量,私有继承; 实心菱形和实线表示
51>.构造函数析构函数可否抛出异常.
	抛出异常时构造和析构函数不能继续执行,可能造成资源泄露.
52>.类如何实现只能静态分配或只能动态分配?***
	只能静态分配:把new/delete运算符重载为类私有静态成员运算符. 需要'static'修饰是因为new时还没有对象.(重载了new就需要重载delete,所以带上了delete的重载)
	只能动态分配:把析构函数声明为protected,但需要提供一个destory函数释放资源.原因如下:
		只能动态分配也就是类外不能调用构造函数,由于new操作符后还需要调用构造,所以构造函数外部还需要访问.
		所以只能限制析构函数在类外的访问,因为外部虽然可以调用构造函数进行静态分配,但编译器检查析构函数的可访问性,如果不可访问编译器拒绝在栈空间为对象分配内存.
		又由于私有析构函数在子类不可访问,protected属性同样可以达到限制外部访问析构函数的目的,所以设置析构函数为protected就行了.
53>.哪些初始化需要放到构造函数的初始化列表中
		1>.引用成员
		2>.const成员
		3>.基类构造函数
		4>.成员的构造函数
	其实所有成员都应该放到初始化列表中初始化,否则相当于多了一步赋值操作.
	初始化顺序是按类中成员的声明顺序进行初始化的.
54>.自定义的构造函数被编译器扩展的过程
		1>.把初始化列表中的初始化操作挪到构造函数的函数体中,并以声明顺序为顺序.
		2>.如果有成员没出现在初始化列表中,但它有默认构造函数,那么默认构造函数必须被调用.
		3>.如果有虚表,那么它必须被设定初值.
		4>.调用基类的构造函数,先non-virtual基类的后virtual基类的.
55>.自定义的析构函数被编译器扩展的部分
		1>.首先执行析构函数的函数体
		2>.如果有成员对象,按与声明相反的顺序调用其析构函数.
		3>.如果有虚表指针,则被重新定义.
		4>.按照声明顺序调用基类的析构函数,先non-virtual基类的后virtual基类的.
56>.哪些函数不能是虚函数
	构造函数,因为有冲突也没有意义,调用虚函数通过虚表指针在虚函数表中查找函数入口地址,而在构造对象时对象还不存在所以是冲突的.
	静态函数,静态函数属于类,不属于某个对象,因此也没有意义.
	内联函数,内联函数在编译期间替换函数体,虚函数是在运行期绑定的.
	友元函数,不属于类成员,没有被继承一说,所以也不存在虚函数这一特性.
	普通函数,不属于类成员,没有被继承一说,所以也不存在虚函数这一特性.
57>.if和switch在汇编层面的差异
	switch的case大于3个且case值的跨度小于40时,编译器会把switch判断优化为hash表进行跳转执行代码.
	而if条件判断时,尽量把概率高的放在前边有助于减少不必要的判断.
58>.gcc常用编译选项:
	-Wall:打开所有常用的编译警告.
	-W:类似-Wall通常同时指定,对a selection of常见编程错误产生警告.
	-o:指定可执行文件名.
	-c:编译单个源文件时指定产生的目标文件名.
	-static:使gcc静态链接,避免依赖共享库.
	-shared:生成共享库,需要与-fPIC一起使用,如 -fPIC -shared
	-fPIC:告诉编译器产生与位置无关代码,全部使用相对地址.
	-I:指定头文件路径.
	-L:指定库路径.
	-D:定义预处理宏.
	-g:在可执行文件中存储另外的调试信息.
	-ggdb:尽可能的生成gdb可以使用的调试信息.
	-Oleavel:指定优化级别,默认为-O0不进行任何优化.
	-Os:基于目标生成文件大小更小优化.

	静态库生成:ar -rc libhelloworld.a helloworld.o
59>.gdb常用命令:
	attach:附加到当前正在运行的进程.
	detach:脱离附加进程.
	break:设置断点,[文件名:行号][文件名:函数名][函数名][类名:函数名]
	bt:列出当前调用堆栈.
	info thread:列出进程内所有线程的当前栈帧.
	thread num:跳转到num线程栈.
	frame ...:栈帧跳转.
	generate-core-file:以当前状态生成一个core文件.
	print:打印变量或地址.
	x:查看内存. x [单元数:格式:单元字节数] [内存地址]
		单元数:表示打印内存地址之后多少个单元
		格式:x十六进制  d十进制  u十六进制无符号  t二进制
		单元字节数:默认4字节, b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes
	info:打印变量或地址:
	info local:打印局部变量.
	info args:打印函数参数.
	set print element 0:取消字符串打印长度限制.
	next:下一步(F10)
	step:下一步(F11)
	continue:继续执行知道下一个断点.
	quit:退出调试.
	save [breakpoints][tracepoints] 文件名:保存断点信息.
	gdb 可执行文件 -x 断点文件:加载断点文件.
附录:
1>. 模板专题
	模板函数的定义不一定要在头文件中, 定义在头文件中只是其中一种方式.
		1>.模板函数声明和定义在头文件中
		2>.模板函数定义在cpp文件, 调用模板函数的实现文件include这个cpp文件.
		3>.在声明模板函数对应的源文件内触发模板具现化,且具现化出的函数要匹配另一个源文件中模板参数,不然另一个源文件也会出现链接错误.
	避免模板重定义:
		1>.加inline使之成为内联模板函数.
		2>.加extern关键字只声明不定义,然后在实现文件中实现这个模板函数的特化.
		3>.用函数重载替换.
	模板元编程:
		当模板的形参被实参替换时,模板会进行编译期计算,由于模板的参数支持类型参数和非类型参数,所以编译期计算分为：类型计算和数值计算.
		数值计算:利用编译期对模板的具现化,实现编译期的计算.
		类型计算: