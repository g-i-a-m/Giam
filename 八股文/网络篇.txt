1>.TCP四个定时器:
	TIME_WAIT定时器
	重传定时器
	心跳定时器
	滑动窗口死锁避免定时器
2>.TCP为什么可靠?***
	●TCP使用3次握手和4次挥手来建立和关闭全双工连接.
	●有重传机制重传丢失的数据包.
	●拥有滑动窗口和拥塞控制机制避免网络拥塞产生丢包.
	●对每个数据包有检验和按序列号重排.
3>.UDP为什么不可靠?
	udp没有TCP的那些机制.
4>.TCP最大连接数?
	客户端由于端口号是unsigned short类型,所以是65535个;
	服务端由于是4元组确定socket,理论上可达2的48次方,虽然由于硬件资源,操作系统等限制达不到理论值,但通过增加内存及修改最大描述符个数,超10万没问题.
5>.TCP粘包现象***
	1>.TCP是面向字节流的传输协议,在发送端调用send只是把待发送的数据放到的内核的发送缓冲区,由发送缓冲区低水位标志值及negals机制确定何时发送数据及发送数据的长度,也不保证上层的一次send的数据在底层也是一次发送完成.
	2>.再就是在接收端,有内核接收缓冲区低水位标志值来确定何时触发用户进程可读事件,且一次读事件的读取长度不一定是一个数据包.
6>.TCP首部
	源端口和目的端口号:它用于多路复用/分解来自或送往上层应用的数据，其和IP数据报中的源IP与目的IP地址一同确定一条TCP连接。
	序号和确认号字段:序号是本报文段发送的数据部分中第一个字节的编号，在TCP传送的流中，每一个字节一个序号。例如一个报文段的序号为100，此报文段数据部分共有100 个字节，则下一个报文段的序号为200。序号确保了TCP传输的有序性。确认号即ACK，指明下一个想要收到的字节序号，发送ACK 时表明当前序号之前的所有数据已经正确接收。这两个字段的主要目的是保证数据可靠传输。
	首部长度:该字段指示了以32比特的字为单位的TCP的首部长度。其中固定字段长度为20字节，由于首部长度可能含有可选项内容，因此TCP报头的长度是不确定的，20字节是TCP首部的最小长度。
	保留:为将来用于新的用途而保留。
	控制位:URG表示紧急指针标志，该位为1时表示紧急指针有效，为0则忽略；ACK为确认序号标志，即相应报文段包括一个对已被成功接收报文段的确认；PSH为push标志，当该位为1 时，则指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队；RST为重置连接标志，当出现错误连接时，使用此标志来拒绝非法的请求；SYN 为同步序号，在连接的建立过程中使用，例如三次握手时，发送方发送 SYN 包表示请求建立连接；FIN为finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。
	接收窗口:主要用于TCP流量控制。该字段用来告诉发送方其窗口（缓冲区）大小，以此控制发送速率，从而达到流量控制的目的。
	校验和:奇偶校验，此校验和是对整个TCP报文段，包括TCP头部和 数据部分。该校验和是一个端到端的校验和，由发送端计算和存储，并由接收端进行验证，主要目的是检验数据是否发生改动，若检测出差错，接收方会丢弃该TCP报文。
	紧急数据指针:紧急数据用于告知紧急数据所在的位置，在URG标志位为 1 时才有效。当紧急数据存在时，TCP 必须通知接收方的上层实体，接收方会对紧急模式采取相应的处理。
	选项:该字段一般为空，可根据首部长度进行推算。主要有以下作用：
		TCP 连接初始化时，通信双方确认最大报文长度。
		在高速数据传输时，可使用该选项协商窗口扩大因子。
		作为时间戳时，提供一个 较为精准的 RTT。
	数据:TCP报文中的数据部分也是可选的，例如在TCP三次握手和四次挥手过程中，通信双方交换的报文只包含头部信息，数据部分为空，只有当连接成功建立后，TCP包才真正携带数据。
7>.处理TCP粘包现象?***
	1>.固定数据包长度(差).
	2>.数据包头添加包长度扩展位.
	3>.添加数据包标记(差).
8>.简述TCP协议的滑动窗口/流量控制.***
	滑动窗口是传输层进行流量控制的方式, 接收端通过告知发送方自己的窗口大小,控制发送方的发送速度, 防止接收方接收过多数据而导致接收缓冲区溢出.
	接收方回应的ACK包是存在丢失的可能的,为了防止双方一直等待滑动窗口不为0而出现死锁情况,此时就需要坚持计时器来辅助发送方周期性地向接收方查询,以便发现窗口是否变大
9>.TCP拥塞控制***
	慢开始:初始发送速率为1,如果未检测到拥塞则把发送速率增加一倍,直到速率到达慢开始门限.
	拥塞避免:当发送速率大于慢开始门限值,且未检测到拥塞,则发送速率线性增加,从而保持较高发送速率且尽可能推迟发生拥塞的时间.
	快重传:当接收端收到未按顺序到达的数据则应答重复的ack(按顺序接收的最后一包数据的ack),如果接收端连续收到3包对同一包数据的ack,则立即启动对下一包数据的重传,而不用等到重传定时器超时.
	快恢复:当发送端收到3个重复的ack,就把当前的慢开始门限和发送速率设置为当前发送速率的一半,开始执行拥塞避免策略.
10>.TCP序列号的作用
	1>.序列号代表当前数据包在数据流中的位置,用于解决乱序问题.
	2.防止过期的syn被处理.
	3.用于重传和确认.
	4.防止重复的数据包抛给上层.
11>.TCP套接字什么情况下可读？
	1>.监听socket有已完成连接.
	2>.接收缓冲区中已经接收的数据长度大于接收缓冲区低水位标志线.
	3>.有异常错误待处理.
	4>.对端关闭.
12>.TCP序列号猜测攻击
	假设有服务器S,客户端C,攻击者X
		X->S:SYN(序列号=M),src-addr=C
		S->C:SYN(序列号=N),ACK(应答序列号=M+1)
		X->B:ACK(应答序列号=N+1)
	虽然X可以冒充C给S发消息,但应答是不会发送给冒充者X的,X只能通过猜测序列号继续发送请求.
13>.TCP套接字什么情况下可写？
	socket发送缓冲区中的可用空间字节数大于等于socket发送缓冲区低潮限度的当前值.
	连接的写这一半关闭.对于这样的socket的的写操作将产生信号SIGPIPE; 
	有异常错误条件待处理.
14>.传输层与网络层的区别
	传输层负责提供进程间的逻辑通信.
	网络层负责提供主机间的逻辑通信.
15>.路由尾部丢弃策略导致的`全局同步`现象.
	导致经过此路由器的TCP连接在同一时间进入慢开始状态,使得网络的通信量突然下降很多,而在网络恢复正常之后通信量又突然增大很多.
	路由器采用随机早期检测(RED:randomearly detection),避免全局同步.
		路由器通过维持两个参数,即队列长队最小门限/最大门限.
			当队列平均长度小于最小门限则放入队列.
			当队列平均长度在最小门限与最大门限之间,则按某一概率丢弃分组.
			当队列平均长度大于最大门限则直接丢弃.
16>.为什么TCP握手需要三次?***
	TCP进行可靠传输的关键在于维护了一个起始序列号,三次握手即是相互告知对方其实序列号,并确认对方已经收到了序列号.
		握手只有两次,发生丢包则另一端的序列号无法得到确认.
		又由于TCP是全双工,自己的应答和请求合并可以节省RTO时间.
18>.TCP序列号为什么不能固定?
	1>.防止数据冲突,无法得知数据包是新连接的还是旧连接的.
	2>.降低TCP序列号预测攻击的可能性
19>.TCP半连接队列
	当服务器收到SYN后处于SYN_RECV状态,内核会把这种状态的socket放入半连接队列,等连接建立完成移到已连接队列,等待accept取走队头已连接socket.
20>.SYN攻击
	利用TCP半连接队列,发送大量连接请求而不完成连接,消耗半连接队列资源,CPU及内存,致使正常请求无法被相应.
	解决方式:
		1>.记录IP,若连续收到同一IP发来大量半连接,则禁止该地址发来的数据报一段时间.
		2>.SYN Cookies验证
21>.TCP的四次挥手
	1st挥手:客户端发送FIN来关闭向服务器发送数据,客户端进入FIN_WAIT1状态.
	2st挥手:服务器收到FIN后向客户端应答ACK,序列号为FIN序列号+1;服务端进入CLOSE_WAIT状态.
	3st挥手:服务器发送FIN来关闭向客户端发送数据,服务器进入LAST_ACK状态.
	4st挥手:客户端收到FIN后进入TIME_WAIT状态,然后返回ACK给客户端,确认后服务器进入CLOSED状态.
22>.为什么TCP需要4次挥手?
	一端关闭仅表示本端不会向对端发送数据,另一端还可以向本端发送数据,所以不能将确认和关闭请求同时发送,待本端发送结束(超时或全部传送到对端)再发送关闭请求,所以最少需要4次.
23>.为什么需要TIME_WAIT状态?
	1>.TCP是全双工的,两端需要相互关闭向对端发送数据,如果第3次第4次挥手丢包的话,处于半关闭状态的套接字将无法正常关闭.
	2>.2MSL可以保证漫游在网络中的分组消失,而不会被新的连接接收.
24>.出现大量套接字CLOSE_WAIT状态的原因?
	对端主动关闭socket后,本端套接字会处于CLOSE_WAIT状态,如果本端一直没有调用close则会一直处于CLOSE_WAIT.
	产生的原因:
		1>.服务器没有检测到对端已关闭. recv()时当指定读取长度不为0时返回0
		2>.linger关闭设置的超时时间过长,且一直无法把系统缓冲区中的数据发送走.
25>.客户端突然崩掉或客户机死机怎么办?
	使用心跳保活,超时释放对应连接及资源.
25>.TCP常见异常
	1>.应用崩溃:系统自动关闭一打开文件描述符,导致内核发送FIN,对端在读该套接字时会返回EOF由此可知对端状态变化.
	2>.机器崩溃:内核无法做出反应,对端不会收到任何通知,另一端读该套接字时会被挂起或者得到EAGAIN错误,另一端写时会持续重传,直到TCP放弃重传.
	3>.机器崩溃重启:内核无法做出反应,另一端读该套接字时会被挂起或者得到EAGAIN错误,当另一端写时会收到RST报文(如果未处理该信号再次写该套接字会触发sigpipe信号).
	4>.网络断开:数据无法发送到对方,另一端写时会持续重传,直到TCP放弃重传.
	5>.半开连接:客户端发送SYN包,服务端收到并回复SYN+ACK后,服务端进入SYN_RCVD状态,此时服务端的socket会放到半连接队列.
	半连接队列大小默认128;服务端没有收到最后一个ACK的话,SYN_ACK丢包的话默认重发5次.
	6>.半关连接:TCP连接只有一方发送了FIN,另一方没有发出FIN包,仍然可以在一个方向上正常发送数据;通过调用函数shutdown()发送FIN告诉对方我不会再发送数据了(但还可以接收数据).
26>.简述DNS协议
	DNS协议是基于UDP的应用层协议,根据用户提供的域名,解析出对应的IP地址,给用户进行访问.
27>.DNS解析过程
	1>.用户发出查询请求后,首先在本地计算机缓存中查找,若没有将请求转发到DNS服务器.
	2>.本地DNS服务器会在自己的区域里查找域名,找到则根据此记录进行解析,如果没有找到则再本地缓存里查找.
	3>.本地DNS服务器没有找到客户机查询的信息,则会将此请求转发到根域名DNS服务器.
	4>.根域名服务器解析请求的根域部分,它把包含的下一级DNS服务器的地址返回给客户端的DNS服务器地址.
	5>.本地DNS服务器根据返回的信息接着访问下一级DNS服务器.
	6>.这样递归的一级一级接近查询目标,最后在有目标域名的服务器上得到相应IP信息.
	7>.本地的DNS服务器将查询结果返回给客户端,解析完成.
28>.简述HTTP协议
	http协议是超文本传输协议,它是基于TCP的应用层协议.
29>.简述HTTP cookie
	HTTP协议本身是无状态的,为了使其能够处理更加复杂的逻辑,HTTP/1.1引入了Cookie来保存状态信息.
	Cookie由服务器产生,发送给客户端后保存起来.当客户端再次请求时携带Cookie,服务器可辨识客户端是哪个,可以做个性化推送,免密码登录等.
30>.简述HTTP session
	session用于标记特定用户信息,保存在服务器的一个文件中,一般客户端携带Cookie对服务器进行访问,服务器可通过Cookie中的session id查询服务器记录的客户端信息.
31>.简述HTTP状态码和对应信息
	1XX:指示信息,表示正在处理.
	2XX:请求正常处理完毕.
	3XX:重定向,要完成的请求需要进行附加操作.
	4XX:客户端错误,请求有语法错误或者请求无法实现.
	5XX:服务器错误,服务器处理请求出现错误.
	常见错误码:  301:永久重定向  302:临时重定向  400:请求报文有错误  403:服务器禁止访问资源   404:未找到指定资源.
32>.转发和重定向的区别
	转发是服务器行为,服务器直接向目标地址访问URL,将相应内容读取之后应答给客户端,对客户端来说是透明的.
	重定向是利用服务器返回的状态码来实现,由服务器返回的URL,进行第二次请求来访问目标资源.
33>.简述http1.0与1.1
	http1.0规定的请求头和请求尾,响应头和响应尾,每个请求都是一个单独的连接,连接无法复用(短连接).
	http1.1默认开启长链接,可以进行多次请求和响应. 支持管道,第一个请求发送出去后不必等待应答即可发送第二个请求.
	http1.1也不支持服务器主动push.
	http2.0支持多路复用,可以同时传输多个文件.
34>.http与https的区别
	http传输的内容是明文,且双方无法验证对方身份.https采用非对称加密交换对称加密秘钥, 然后使用对称加密传输,在验证客户端身份时需要用到ca证书.
	https可以简单的看作是http+TLS/SSL
35>.https的连接过程
	
36>.GET与POST区别
	GET:指定资源请求数据, 刷新无害, 请求的数据会附加到URL中,传输数据的大小受浏览器实现的限制.
	POST:向指定资源提交要被处理的数据. 刷新会使数据被重复提交. post在发送数据前会先请求头发送给服务器,服务器应答100 continue之后再发送数据.
37>.REST API
	表述性状态转移,利用HTTP中的get, post, put, delete以及其他HTTP方法构成REST中数据资源的增删改查操作.
38>.在浏览器中输入网址后,具体发生了什么?
39>.http requst与response格式
	request格式:
		请求行: 方法(GET/POST/DELETE...) url 协议版本
		请求头:Host,Agent,编码,数据格式等
		Body:数据
	response格式:
		状态行:协议版本,状态码,状态描述
		响应头:server,content type/charset/encoding
		Body:应答的数据
