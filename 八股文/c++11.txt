1>.Lambda匿名函数
	[捕获列表](参数列表) mutable(可选) 异常属性 -> 返回类型 {函数体}
	捕获列表:捕获外部变量列表,默认是传值捕获 &引用捕获  [&]引用捕获所有 [=]传值捕获所有
	参数列表:形参列表
	mutable指示符:用来修饰是否可以修改捕获的变量
	exception:指定函数抛出的异常.
	作用:实现功能闭包,避免功能分散.

2>.新增关键字
	decltype(变量) 编译期间推导类型,例如decltype(a+1) b;
	alignas/alignof指定或获取类的内存对齐要求.
	constexpr 建议编译器进行编译期优化或运算,修饰函数时使函数在编译期会成为常量表达式
		constexpr变量必须在编译时进行初始化,而const变量的初始化可延迟到运行时.
		constexpr函数限制持有和返回的类型为字面值类型(除void外的内置类型),本质上在编译期间可确定值.函数体只能有一行return语句.
	noexcept 作为后缀指示不抛出异常;作为运算符判断表达式是否会抛出异常.
	nullptr 空指针类型,编译器会做类型检查,而NULL可以被定义为整型的0或0值的指针,以避免函数重载时的编译器如何选择困惑(形参为void*与int)
	explicit 修饰构造函数,用来关闭自动(隐式)类型转换特性.
	override 显式声明本关键字修饰的函数是重载
	final 显式声明本关键字修饰的函数不允许子类重载,并且final修饰的函数所属类不能被继承.
	default 指定默认函数的定义
	delete 禁止编译期生成默认赋值操作符函数

3>.变更或扩展关键字
	auto 自动推导变量的类型, 之前版本中自动生命周期基类.
	using关键字
		1>.定义类型别名
		2>.命名空间
		3>.显式不隐藏基类函数
		4>.修改继承来的成员访问权限(public protected等)
		5>.C++11为模板定义别名

4>.序列for循环
	for (auto it : user_map_)

5>.容器可以使用初始化列表.
	map<int,std::string>{{1,"a"},{2,"b"}};
	vector<int> vec{1,2,3};

6>.模板默认类型参数
	template<typename T1=int, typename T2=std::string>

7>.右值引用
	左值:能取地址且有名字.
	右值:不能取地址且没有名字,表达式结束就不存在的临时变量,字面常量,非引用返回值.
	左值引用:对左值进行引用
	右值引用:对右值进行引用
	作用: 
		1.实现移动语义
		2.给中间临时变量取别名
		3.实现完美转发

8>.移动构造与移动赋值操作符
	C++11比之前的类多了两个默认函数:移动构造函数,移动赋值操作符
	(默认构造,拷贝构造,析构,赋值操作符)C++11编译器默认会生成6个函数.

9>.非受限联合体
	C++11允许union中数据成员的类型为POD类型(结构体/类)

标准库STL:
	1>.容器
		std::unordered_map 哈希map
		std::unordered_set 哈希set
		std::array 定长数组,好处是在越界访问时抛出异常
		std::forward_list 单向链表,特定场景下使用比std::list节省了内存提升性能
		std::tuple<...> 元组
		容器的emplace()插入函数没有中间变量的创建和销毁操作.

	2>.string与数值类型转换.比如:
		std::stoi()
		std::stod()
		std::stof()
		std::strtoul()
		std::string::to_string()

	3>.原子性访问
		std::atomic<T> 单一cpu指令,与其他线程的读写指令互斥.

	4>.资源转移
		std::move()
			将左值转成右值(将对象的状态或所有权从一个对象转移到另一个对象,只是转移没有内存拷贝).
			实现上基本等同于类型转换:static_cast<T&&>(lvalue),将左值转换为右值变成将亡值.
			所有源对象为临时对象的拷贝构造行为都可以简化为移动式(move)构造.

	5>.完美转发
		std::forward<T>(t)
			存在的原因:在函数调用时,无论实参为左值还是右值,在函数内部都转化成了左值,使得函数体内转调用时无法判断参数是一个左值还是右值。
			使用完美转发可以根据实参实际类型(左值还是右值),静态绑定到对应的函数重载的版本上,避免都绑定到函数参数左值重载的版本.

	6>.智能指针
		原理是在最后一个智能指针超出作用域时调用其析构函数释放资源.在C++11中加入到标准库中,有以下3种:
		shared_ptr:共享指针对象,可以赋值给shared_ptr或weak_ptr.共享同一份内存,所有这类智能指针都能访问对象,当最后一个引用它的智能指针超出作用域时内存才被释放.
			使用shared_from_this()返回自己的智能指针.
			不能delete get()返回来的裸指针.
			不是new出来的空间要自定义删除器.
			避免循环引用,以免内存泄漏.
		weak_ptr:是作为shared_ptr的补充,不能决定所指对象的生命周期;引用所指对象时,需要通过get()函数获取一个共享型智能指针,如果已经被释放则返回nullptr.
			作用: 配合shared_ptr解决循环引用的问题.有A,B两个类,A中有B的智能指针,B中有A的智能指针,如果都是shared_ptr则永远不会释放,需要其中一个类中使用另一个累的weak_ptr.
		unique_ptr:与shared_ptr相对,独占指针对象,并保证指针所指对象生命周期与其一致.
			作用:独占型智能指针,性能近似于裸指针,不用显式调用析构了.

	7>.线程及锁
		std::thread
			std::thread t(func, arg...);
		std::mutex
			std::mutex:独占的互斥量,不能递归使用,不带超时功能
			std::recursive_mutex:递归互斥量,可重入,不带超时功能
			std::timed_mutex:带超时的互斥量,不能递归
			std::recursive_timed_mutex:带超时的互斥量,可以递归使用
		std::lock
			std::lock_guard<mutex> 自动加解锁
			std::unique_lock<mutex> 自动加解锁,也提供了unlock函数可以手动释放锁.
		std::call_once只调用一次,用于实现单例.
		std::condition_variable条件变量(注意须用mutex进行保护,详见APUE)
		std::promise与std::future相当于golang中的channel的两端,用于传递数据或发送信号.
			std::promise用于返回std::future对象及写入数据.
			std::future用于阻塞等待接收对应std::promise写入的数据.
		thread_local 修饰的变量类似于静态/全局变量,只不过该变量作用域为线程作用域,如果线程内有多个对象包含该变量则共享同一个.

	8>.函数对象与参数绑定
		std::function 可调用对象的包装器,可容纳除了类普通成员函数外的所有可能可调用的对象.用统一的方式处理函数/函数对象,以允许保存和延迟执行它们.
		std::bind 绑定器可以全部绑定,部分绑定,全部不绑定参数,然后返回一个仿函数类型,返回值可以直接赋值给一个std::function

	9>.chrono时间相关
		std::chrono::duration 表示一段时间
		std::chrono::time_point 表示一个具体时间点,比如2021年9月10日10点10分10秒
		std::chrono::clocks
			std::chrono::steady_clock 相对时间(相对于开机)
			std::chrono::system_clock 当前系统的时间
			std::chrono::high_resolution_clock 是steady_clock的typedef

协程:又称为非抢占式用户级线程;其实协程只是一个函数的泛化,它允许被挂起稍后在挂起点恢复执行.
	协程的执行和中断不由内核做调度,每当有协程主动让出cpu时,由协程调度器保存当前协程的调用栈,然后恢复另一个协程的调用栈,通过指令跳转执行它.
	●普通函数被认为有两个操作:函数调用和函数返回.
		调用操作:
			1>.调用者挂起,然后为被调函数创建一个活跃帧.
			2>.将函数参数,调用者恢复点的指令地址,调用者函数活跃帧地址写入被调函数的活跃帧保存.
			3>.按活跃帧的大小递增栈寄存器(指向栈顶),然后将执行权转交到被调用函数的开始位置.
		返回操作:
			1>.将返回值存储到调用者的活跃帧中.
			2>.销毁被调函数活跃帧中保存的参数及局部变量,并释放该活跃帧内存.
			3>.将栈寄存器设置为指向调用方活跃帧,并恢复可能被该被调函数破坏的寄存器,来恢复调用方的活跃帧.
			4>.跳转到保存的调用方的恢复点.
		注:
			根据函数调用约定来划分调用方和被调用方这两种操作谁负责.
			活跃帧是存储特定函数调用的当前状态的内存块,状态包括函数参数及局部变量.
			对于`普通`函数,活跃帧还包括从函数返回时要执行的指令的地址,以及调用函数的活跃帧的地址.可以将这些信息看作是对函数调用的"继续执行"的描述.
			内存--栈中的"活跃帧"称为"栈帧".
	●协程泛化了函数的操作,将调用和返回操作中的一些步骤划分为三个额外的操作:挂起,恢复,销毁.
		挂起操作:
			在函数的当前点挂起协程的执行,在不破坏活跃帧的情况下将执行权转交给调用方或恢复调用方.在挂起协程后挂起点上的任何对象都仍然是可用的.
			1>.通过co_await或co_yield关键字在协程函数中指定挂起点.
			2>.当协程执行到某个挂起点时,将寄存器中的值写入到协程帧,将挂起位置也写入协程帧用于恢复操作,或者销毁时知道哪些对象需要被销毁.
			3>.将执行权交给调用方/恢复调用方,并释放协程`活跃帧`的`栈帧`部分(将其从栈中弹出).
			当协程第一次挂起时,将返回一个指向协程帧的句柄给调用方,该句柄用于以后恢复或销毁协程操作的参数.
		恢复操作:
			1>.使用挂起时返回的handle调用resume(handle)方法,会分配一个新的栈帧.
			2>.将调用者的返回地址存储在栈帧中.
			3>.从协程帧加载恢复点,将执行权转移到上次函数的挂起点.
			当协程下一次挂起或运行完毕时,将恢复对调用resume(handle)函数的执行.
		销毁操作:
			1>.使用挂起时返回的handle调用destroy(handle)方法,将调用所有局部变量的析构函数,然后释放协程帧使用的内存.
			2>.再将执行权转交到destroy()的调用处.
		注:
			由于协程不是嵌套调用,所以活跃帧不能使用栈内存,只能使用堆来保存.
			从逻辑上可以将协程的活跃帧看作两部分组成:
				协程帧部分:用于保存协程的活跃帧的部分,在协程被挂起时也持续存在.
				栈帧部分:仅在协程执行时才存在,并在协程挂起(并将执行转交回调用方/恢复调用方)时释放,用于保存不跨越挂起点的变量.
		协程还包括调用操作和返回操作
			调用操作:
				协程的调用操作与普通函数的调用操作基本相同;但函数调用是在返回时恢复调用方,而协程是在第一个挂起点恢复调用方.
				1>.对协程执行调用操作时,也是分配一个新的栈帧,将参数写入栈帧,将返回地址写入栈帧,并将执行转交到协程,这与调用普通函数完全相同.
				2>.协程所做的第一件事是在堆中分配一个协程帧,并将参数从栈帧复制/移动到协程帧,以便参数的生命周期超过每个挂起点.
			返回操作:
				协程的返回操作与普通函数的返回操作略有不同.
				1>.当协程执行返回语句(co_return操作符)操作时,它会将返回值存储在某个地方,然后销毁局部变量.
				2>.然后协程执行挂起操作/销毁操作,将执行权转交给调用方/恢复调用方.
	●目前协程框架一般都是设计成1:N模式(一个线程作为容器里面放置多个协程),协程自己主动让出CPU,通知协程池里面的调度器切换到其他协程.
	协程优点:
		1>.协程在用户态,栈大小比线程的栈小,一个进程可以容纳更多协程.
		2>.上下文切换开销更少,提高CPU的有效使用率.
		3>.由于没有竞争不需要加锁(M:N模式的协程例外,比如golang的协程).
		4>.按照同步思维写异步代码.
		5>.对IO密集型效率好.由于IO操作耗时远小于CPU的操作,往往需要CPU去等IO操作完成,大量线程切换使CPU的有效负载率并不高.
		6>.协作式调度比抢占式调度有优势的业务场景.
	协程缺点:
		1>.不能有阻塞操作,否则整个线程(协程池)被阻塞.
		2>.对CPU密集型没有优势(1:N模式的协程与单线程相当).
	根据协程中断后如何调度其他协程可分为:
		对称协程:挂起时控制权转移给其他对称协程.
		非对称协程:挂起时控制权转移给调用者.
	根据是否有自己的堆栈可分为:
		有栈协程:每个协程有自己的栈.
		无栈协程:所有协程共享同一个栈称为无栈协程.
	boost协程:
		Boost.Corountine2 非对称有栈协程
			void coro_func(boost::coroutines2::coroutine<void>::push_type& yield) {
				yield.get();//通过get()取外部传入的数据
				yield();//挂起点1
				yield();//挂起点2
			}
			boost::coroutines2::coroutine<void>::pull_type coro_(coro_func,std::placeholder_1);
			coro_();//启动/恢复协程
	c++20协程:
		
	golang协程:
