设计模式的作用和优点:
	1>.减少重构工作量.
	2>.减少耦合度.
	3>.增加修改代码的复杂度.
	4>.提升易用性.

开闭原则:对扩展开放对修改关闭,以降低维护带来的风险.
单一职责原则:一个类只负责一个职责;降低代码复杂度,以及变更引起的风险.
依赖倒置原则:上层不应该依赖低层,而应依赖接口或抽象类编程;更利于代码结构的升级扩展.
接口隔离原则:将不同功能定义在不同接口中实现;功能解耦,高内聚、低耦合.
里氏替换原则:不能破坏继承体系,子类重写函数功能发生改变不应影响父类方法的含义.
迪米特法则:一个类应该保持对其它对象最少的了解和依赖,降低耦合度.
合成复用原则:尽量使用组合或者聚合关系实现代码复用,而不是继承达到软件复用的目的.

这些原则的目的只有一个:降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。
口诀:访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改.

依据模式的目的可分为:创建型,结构型,行为型三种.

第一部分:创建型模式,与对象的创建有关.
	1>. 简单工厂:定义一个算法接口的抽象基类,其他具体算法继承并实现这个抽象类,然后针对不同的算法进行实例化.
		工厂方法:定义一个用于创建对象的接口,让子类决定实例化哪一个类,遵循了开放—封闭原则.
		抽象工厂:提供一个创建一系列相关或相互依赖对象的接口,而不需指定他们具体实现的类.

	2>. 建造者/构建器模式:将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示(适用于一些基本部件不会变,而其组合经常变化的时候,将变与不变分离开).
		●使用:通过构建器提供各个组成部分的构建方法,然后通过构建器对象生成整体对象.
		●e.g.:早餐摊位构建黑胡椒培根手抓饼,川味烤肠手抓饼的构建,都包含饼皮,酱汁,配料,配菜.构建类提供饼皮,酱汁,配料的构建,派生类实现接口,由组装器组合起来各个部分制作出不同的手抓饼.
		●优点:将产品本身与产品的创建过程解耦,使得相同的创建过程可以创建不同的产品对象.

	4>. 原型模式:用一个已经创建的实例作为原型,通过复制该原型对象来创建一个和原型相同或相似的新对象.
		●说明:功能类似于拷贝构造函数(原型模式通过clone接口能够通过基类指针来复制派生类对象,拷贝构造函数不行).

	5>. 单例模式:保证类对象的全局唯一性.
		饿汉模式:由于在类加载的时候就进行了实例化,即使没用到这个实例还是会加载,从而造成内存浪费.
		懒汉模式:用到时才创建实际对象,但须注意线程安全问题(可使用锁或pthread_once,注意进锁之后须再判断一次指针是否为空).

第二部分:结构型模式,处理类或对象的组合.
	1>. 适配器模式:用于包装不兼容接口,用适配器包装被适配的类或对象的接口,使适配器类提供调用者期待的接口.
		●e.g.:小成买了一个进口的港版iphone,随机附带的充电器输入电压是110v的,与国内220v电压不兼容;此时需要一个适配插头把家里插座的220v电压转成110v输出到附带充电器插头来充电.
		●优点:复用性,解耦性,符合开放-关闭原则.

	2>. 桥接模式:使用对象间的组合关系解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化(用组合关系代替继承关系来实现).
		●使用:把变化维度封装成类,使一个变化维度的类对象成为另一个变化维度类对象的成员,替代继承模式防止类数量成倍增长.
		●优点:避免继承带来的类成倍增加问题,抽象与实现分离扩展能力强,符合开闭原则,合成复用原则,实现细节对客户透明.

	3>. 组合模式:类似于list容器中可以包含一个元素或另一个list.

	4>. 装饰模式:动态地将责任附加到对象上,若要扩展功能装饰者提供了比继承更有弹性的替代方案.
		●优点:每加一种功能只需要多装饰一次即可,避免了重复设计大量的相似类.

	5>. 外观模式:为多个复杂子系统提供一个统一的接口,使这些子系统更加容易被访问,外部应用程序不用关心内部子系统的具体细节.
		●e.g.:比如对不同数据库的访问,都使用统一连接断开及增删改查.
		●优点:降低使用复杂度,便捷性(无须关心子系统的工作细节),减少相互依赖(客户端与子系统类无需关联).

	6>. 享元模式:在需要创建大量对象时,如果已有相同对象则直接返回已有的对象,避免重新创建.

	7>. 代理模式:代理类位于客户类和委托对象之间起到中介的作用,其特征是代理类和委托类实现相同的接口,由代理把请求传递到委托对象.
		●优点:符合开闭原则,便于增加功能而

第三部分:行为模式,对类或对象之间怎样交互和怎样分配职责进行描述.
	1>. 职责链模式:gstreamer和Mediastream中的pipeline均是职责链模式.
		●优点:降低耦合度,简化了对象,允许动态增删责任.

	2>. 命令模式:将请求方法封装成一个对象，执行者通过操作对象来执行命令对应的操作,通常由撤销和恢复的功能.

	3>. 解释器模式:采用递归调用方法解释一个特定的上下文为一个抽象语法树.

	4>. 迭代器模式:又称为游标模式,提供一种方法顺序访问一个容器中的各个元素而又不暴露该元素.

	5>. 中介模式:使类之间的相互依赖,变成使中介类和它们之间的依赖,原来类之间的依赖就不存在了而变成只和中介类交互就可以了.
		●说明:QQ客户之间的都是和QQ服务器(中介者)交互,而不是直接交互.

	6>. 备忘录模式:在不破坏封装性的前提下捕获一个对象的内部状态,并在该对象之外保存这个状态,以便后续需要时能将该对象恢复到保存的状态.

	7>. 观察者模式:又被称为发布订阅模式.

	8>. 状态模式:有些情况对象处于不同的状态需要作出不同的行为,通常采用swatch-case或if-else来控制,这种方式违反了开闭原则.
		●使用:把状态和相应处理封装到一个状态对象中,上层通过这个状态对象的抽象接口执行相应动作(替代if-else).

	9>. 策略模式:定义一系列的算法,把每一个算法封装起来,并且使它们可相互替换,使得算法可独立于使用它的客户而变化.

	10>.模板模式:定义一个操作中的算法的骨架而将一些步骤延迟到子类中,模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤.

	11>.访问者模式
		●说明:
		●使用:
		●e.g.:
		●优点:
		●缺点:

