第一章:UNIX基础★★★
	1>. 操作系统可定义为一种控制计算机硬件资源并提供程序运行环境的软件;通常被称为内核.内核的接口被称为系统调用,公共函数库建立在系统调用接口之上,应用程序既可使用公共函数也可使用系统调用.
	2>. shell是一个命令行解释器,它读取用户输入,然后执行命令.
	3>. UNIX文件系统是目录和文件的一种层次结构,所有东西的起点都是根的目录. 目录是一个包含目录项的文件，每个目录项都包含文件名和文件属性.
	4>. 每个进程都有一个工作目录, 进程内所有相对路径都从工作目录开始解释. chdir函数用于修改进程的工作目录.
	5>. 用户登录时工作目录设置为起始目录,该起始目录从口令文件中相应用户的登录项中获得.
	6>. 文件描述符是内核用以标识一个进程正在访问的文件,进程通过文件描述符对文件或设备进行读写或设置属性.
	7>. 程序是一个存储在磁盘上某个目录中的可执行文件,程序的执行实例被称为进程. 进程内的所有线程共享同一地址空间,文件描述符,栈以及进程相关的属性.
	8>. linux支持线程间相互独立的errno错误变量,使用基于__error_location()函数定义的error()宏获取错误号;strerror函数获取错误信息,perror打印错误号对应错误信息到标准错误上.
	9>.用户ID是一个数值用来确定一个用户;用户ID为0为根用户或超级用户;超级用户对系统有自由的支配权.
		组ID是由系统管理员在指定用户登录名时分配的;可以把多个用户分成一组,对一个组进行开放或禁用某个权限,方便权限配置.
		附属组使用户可以属于多个组(一个人身兼数职的情况),大多数系统最少支持16个附属组.
	10>.信号是进程间通信IPC的一种,用于通知进程发生了某种情况. 信号可按系统默认方式处理,或注册信号处理回调捕获该信号.
	11>.用户cpu时间是进程在用户态执行指令占用的时间量.
	    系统cpu时间是进程在内核态执行指令占用的时间量.
		时钟时间是人类钟表表示的进程运行时间的总量,是用户cpu时间+系统cpu时间+中断/挂起时间的总和.
	12>.系统调用:操作系统(内核)提供的服务的入口点,由系统调用向内核请求服务.系统调用通常是提供一种系统服务的最小接口(e.g., sbrk处理存储空间分配,malloc基于此系统调用实现).
		C函数库一般提供较复杂功能,直接或间接依赖于系统调用.

第二章:UNIX标准及实现
	1>. POSIX:可移植操作系统标准. posix限制值定义在limits.h中;运行时限制值通过sysconf(flag)/pathconf(szPath)/fpathconf(fd)函数获取.
	2>. 编译时选项定义在unistd.h中.
	3>. 功能测试宏_POSIX_C_SOURCE用于排除任何非POSIX实现(e.g., gcc -D_POSIX_C_SOURCE=200809L main.c).

第三章:文件IO
	1>. STDIN_FILENO(0),STDOUT_FILENO(1),STDERR_FILENO(2)
	2>. open/openat函数用于打开或创建一个文件.常用flags参数:读/写/追加/不存在则创建/不是目录出错/已存在则出错/打开的是链接符号则出错等等
		openat函数第一参数fd,如果path参数为绝对路径则忽略fd参数,功能和open一样.
			如果path为相对路径,则fd参数指定path在文件系统中的开始地址(fd目录的路径拼接path参数).
			如果path为相对路径且fd值为AT_FDCWD,则path拼接当前工作目录.
		open函数返回的文件描述符一定是最小的未使用文件描述符数值.
		open系函数的路径名过长时,有可能会截断路径名打开或创建也可能会返回错误._POSIX_NO_TRUNC常量用于判断这种情况采用何种策略.不同文件系统_POSIX_NO_TRUNC的值可能变化,可通过fpathconf/pathconf在运行时检查采用何种策略.
	3>. create(path,mode)函数只能以写的方式创建文件并返回描述符,如果文件存在则返回-1.
	4>. close(int fd)函数关闭一个打开的文件.
	5>. lseek(int fd,off_t offset,int whence)函数用于设置文件游标. whence参数为SEEK_SET从文件起点设置偏移,SEEK_CUR从当前游标设置偏移,SEEK_END从文件为设置偏移.
	6>. 文件偏移量可大于文件长度,下次写时会加长改文件并构成一个空洞;文件空洞并不要求占用磁盘存储区,具体由文件系统实现.
	7>. read/write用于读写数据.
	8>. 内核中使用3种数据结构表示打开的文件:
		1>.文件描述符表:每个进程在内核中的进程表中都有一个记录项,记录项包含一张文件描述符表,每个已打开的文件描述符占用一项(文件描述符标志,指向文件表项的指针)
		2>.内核为每个打开的文件维持一张文件表项,文件表项包含:文件状态(读/写/追加/同步/非阻塞等);文件偏移量;对应v节点指针.
		3>.v节点包含文件类型/文件操作函数的指针及i节点指针. i节点包含文件所有者信息,文件长度,文件实际数据在磁盘上位置的指针.
	9>. 如果两个进程打开同一个文件,则两个进程拥有各自的文件表项及同一个v节点和i节点.
	10>.文件描述符标志与文件状态标志的区别:
		1>.文件描述符标志:存在于进程表项里的文件描述符表中,目前只有一个值close_on_exec,用于控制子进程exec时是否关闭继承的文件副本.
		2>.文件状态标志:存在与文件表项中,有只读/只写/追加写/非阻塞等状态,用于控制文件IO的方式.
	11>.lseek()+write()并行写时存在覆盖的情况,以O_APPEND模式打开追加写操作是原子操作.
		pwrite/pread函数提供原子性的定位并读写的功能,执行IO完成后不会更新当前的文件偏移量.
		open(path,O_CREAT|O_EXCL)是一个原子的判断不存在并创建的操作,文件存在的话则返回-1.
	12>.dup(int fd)用于复制文件描述符fd的副本.dup2(fd,fd2)用于fd2参数接收复制文件描述符fd的副本.
		复制后的新文件描述符与fd共享同一个文件表项(使用同一个文件偏移量).
	13>.当写入文件时内核只是将数据写入了内存缓冲区中,并没有立即写入磁盘,被称为延迟写入.
		sync()将所有修改过的缓冲区排入写队列就返回,并不等待写磁盘操作结束.
		fsync(fd)将fd文件的修改数据写入磁盘才返回;并且更新文件属性.
		fdatasync(fd)将fd文件的修改数据写入磁盘才返回;只写入数据不更新文件属性.
	14>.fcntl(fd,cmd,...)函数提供5个功能:
		1>.复制文件描述符 例:cmd=F_DUPFD时
		2>.设置/获取文件描述符标志,用于设置修改exec时继承的文件描述符的行为. 例:cmd=F_SETFD时
		3>.设置/获取文件状态标志,用于获取或修改文件读写非阻塞权限. 例:cmd=F_SETFL时
		4>.设置/获取异步io权限,用于获取或修改接收异步IO信号的进程ID,进程id由第三个参数指定. 例:cmd=F_SETTOWN时
		5>.设置/获取记录锁 例:cmd=F_SETTLK或F_SETTLKW时
		通常在设置文件描述符标志或文件状态标志时应先获取之前的值,或上变更的值再设置进去,以避免覆盖擦除原有的权限.
	15>.ioctl(fd,request,...)是io操作的杂物箱.
		每个设备驱动程序都可以定义它自己的一组ioctl命令,系统则为不同种类的设备提供通用的ioctl命令.
	16>.系统提供了/dev/fd的目录,目录项是名为0,1,2等的文件,open("/dev/fd/n",mode)等效于dup(0);并且mode参数只能和原打开模式相等或是一个子集.

第四章:文件和目录
	1>. 获取文件信息接口:
		1>.stat函数获取pathname文件的信息结构;
		2>.fstat获取fd上打开文件的信息结构;
		3>.lstat获取符号链接的信息结构(不是链接引用的原始文件的信息结构);
		4>.fstatat获取相对fd的路径的path指向的文件的信息结构.
		信息结构主要包括:文件类型,mode权限,链接到此文件的计数,用户id,组id,修改时间等等.
	2>. 文件类型:
		1>.普通文件:包含某种形式的数据,可为文本或二进制数据,由对应应用程序解释.
		2>.目录文件:包含了其他文件的名字及指向这些文件相关信息的指针.
		3>.块特殊文件:提供对设备(e.g., 磁盘)带缓冲的访问,每次访问以固定长度为单位进行.
		4>.字符特殊文件:提供对设备不带缓冲的访问,每次访问长度可变(系统中的所有设备都是3或4的一种).
		5>.命名管道FIFO
		6>.套接字:包含网络套接字和UNIX域套接字.
		7>.符号链接:符号链接文件指向另一个文件,也称为软连接;由ln -s命令创建(不带-s创建的是硬链接).
		软链接:
			1.只是一个符号连接,所以文件大小都很小
	　　　　2.当运行软连接的时候,会根据连接指向找到真正的文件,然后执行
	　　　　3.所有软连接文件的权限是777,而真正的权限是由指向的那个文件决定的
	　　　　4.原文件丢失,软连接无法访问,会报文件不存在错误.
	　　　　5.ls -al以后，软连接后面箭头指向的是原文件
		硬链接:
			1.硬链接要求链接和文件处于同一文件系统.
			2.原文件和连接文件的属性完全一样
	　　　　3.连接文件和原文件的关系类似于：复制+同步更新
	　　　　4.当原文件丢失，硬连接文件还可以访问
	　　　　5.不能跨分区，不能针对目录使用
	　　　　6.原理：原文件和硬链接文件的i节点号是相同的(ls -i)，1个文件名对应一个i节点，1个i节点可以通过多个文件名访问，所以他们的属性完全相同，并且修改了其中一个的内容另一个也会跟着修改
	3>. 进程相关的ID有6个,分别是:
		实际用户/组ID:标识当前登录的用户,取自口令文件中的登录项.
		有效用户/组ID:用于文件访问权限检查. 通常有效用户ID等于实际用户ID,有效组ID等于实际组ID.
		保存的设置用户/组ID:用于在置位了文件的设置用户ID位时,exec函数执行此文件时替换有效用户ID为文件所有者ID,暂存原有效用户ID用于后续恢复;是搭配文件保存的设置用户ID位使用的.
	4>. 所有7种文件都有访问权限,用户读/写/执行,组读/写/执行,其他读/写/执行9种权限.进程每次通过open/exec都需要检查相应权限.
	5>. 新文件或新目录的用户ID被设置为进程的有效用户ID
	6>. access函数按进程的实际用户ID进行读/写/执行权限的测试,当通过设置的用户ID位替换过有效用户ID时,可通过此函数测试实际用户ID对一个文件的访问权限.
		faccessat函数时使用相对路径参数进程测试的版本.
	7>. 文件模式的创建屏蔽字:在用open/create创建文件时指定的用户/组/其他读写执行等权限;通过umask()函数可设置当前进程屏蔽掉的文件权限,此设置不影响父进程.
	8>. chmod函数用于修改文件访问权限.
		chown函数用于修改文件所属的用户或组.
	9>. 普通文件的长度可为0,符号链接的长度为路径名的长度.
	10>.turncate()函数用于截断文件,截断后的部分则不能访问了.如果截断长度大于文件当前长度则文件长度将增加.
	11>.磁盘会划分若干分区,每个分区包含若干柱面组,柱面组中主要包含若干i节点,数据块,目录块.
		i节点包含文件类型,访问权限,文件长度,指向文件数据块的指针.
	12>.link函数用于创建已有文件的符号链接;
		linkat函数是使用相对路径创建符号链接的版本.
		unlink/unlinkat函数用于解除文件的链接,使所引用文件的链接计数减1.当一个文件的链接计数为0时且没有进程打开该文件,则其内容被删除,通常使用unlink函数确保程序崩溃后也能删除临时文件.
		remove函数用于解除文件和目录的链接.
	13>.rename/renameat函数用于文件重命名.
	14>.symlink/symlinkat函数用于创建符号链接.
	15>.readlink/readlinkat函数用于读取符号链接指向的原始文件的路径名(返回的路径名没有结束符,通过返回的长度判断).
	16>.utimes/utimens函数用于更改文件访问和修改时间.
	17>.mkdir/mkdirat/rmdir函数用于创建删除目录.
	18>.每个进程都有一个当前工作目录,作为相对路径的起点.
		chdir/fchdir函数用于修改进程的当前工作目录.getcwd函数用于获取进程当前工作目录的绝对路径.

第五章:标准IO库
	1>. 第三章中文件IO函数都是围绕文件描述符的;而标准IO库打开或创建一个文件时使一个流与文件相关联.
		标准IO流可采用`单字节字符集`或`宽字符集`,称为流的定向. 当流被创建后是没有定向的,第一次使用什么字符集则将定向为什么字符集.
		通过freopen()清除流定向和fwide()设置流的定向可达到修改流的定向的目的.
	2>. 流缓冲有三种模式: 全缓冲:缓冲区满才进行实际IO; 行缓冲:遇到换行符才进行实际IO; 不带缓冲:不进行缓冲存储,立即进行IO(标准错误通常是不带缓冲).
		setbuf/setvbuf函数用于设置流的缓冲模式.
	3>. fopen/freopen/fdopen通过文件路径名或文件描述符打开一个流. fclose()函数关闭一个打开的流.
	4>. getc/fgetc/getchar函数用于从流中读取一个字符.
		ungetc函数将一个字符压送回流(压送回流的字符可从流中读出).
		putc/fputc/putchar函数用于向流中写入一个字符.
	5>. fgets/gets函数用于从流中读取一行.
		fputs/puts用于向流中写入一行.
	6>. 标准IO库的优点是无需考虑缓冲及最佳IO长度但需要复制两次数据(一次是内核到缓冲区,第二次是从缓冲区到用户程序的行缓冲区); 文件IO的优点是效率高.
	7>. fread/fwrite用于二进制IO流的读写.
	8>. ftell函数返回文件流的当前偏移量;fseek设置文件流的偏移量;rewind设置文件偏移量到起始位置.
	9>. fgetpos/fsetpos函数是ISO C标准的文件流偏移量获取和设置.
	10>.printf/fprintf/sprintf格式化输出;scanf/fscanf/sscanf格式化输入.
		格式控制:%[flags][width][precision][length]convtype
		flags:'表示按千分组字符   -左对齐输出   +显示正负号   #加0x前缀   0补零填充
		width:最小字段宽度(指定非负十进制数)
		precision:整型最少位数/浮点型最少小数部分位数/字符串最大字节数.格式为一个点.后跟非负十进制数.
		length:参数长度修饰符.
		convtype:参数的解释. d有符号十进制  u无符号十进制   x无符号十六进制  f浮点数  c字符  s字符串  p指针  C宽字符  S宽字符串
	11>.fileno函数获取一个文件流对应的文件描述符.
	12>.tmpnam()函数用于产生一个与现有文件不同的有效路径名字符串,后续通过open/creat创建临时文件;创建后调用unlink函数达到进程退出后自动删除这个文件的目的.
		tmpfile()创建一个临时二进制文件(wb+)返回文件的指针,此函数创建的文件相当于已经调用了unlink,进程结束后会自动删除这个文件.
		mkdtmp/mkstmp创建临时文件或目录,路径文件名由参数template的后6位占位符替换成随机字符指定的.mkstemp创建的文件进程结束不会自动删除.
	13>.内存流:底层没有文件. fmemopen函数用于可指定自己的缓冲区的内存流的创建.
		open_memstream/open_wmemstream函数分别用于创建字节流的内存流和宽字符的内存流.

第六章:系统数据文件和信息
	1>. 系统口令文件/et/passwd通常包含:用户id,shell字段(为空时取默认值,为/bin/false或/bin/true禁止一个账户),账户有效期等;
	2>. 阴影口令文件/etc/shadow文件是登录口令单向加密(e.g., MD5,SHA-1)后的文件.
	3>. 组文件/etc/group存放用户组信息.
	4>. 主机信息/etc/hosts存放本地配置的域名解析配置.
	5>. /var/run/utmp存放当前登录系统的用户记录.
	6>. /var/log/wtmp存放系统登录登出事件日志.
	7>. uname命令用于获取操作系统名,版本号等信息.
	8>. hostname命令用于获取和设置主机名.

第七章:进程环境★★★
	1>. 可执行文件的装载到进程开始执行:
		1>.创建新进程:bash进程调用fork系统调用创建一个新的进程,然后新的进程通过调用execve系统调用来执行指定的ELF文件.
		2>.检查可执行文件类型:当进入exec系统调用后,进行一些参数的检查复制之后读取可执行文件的前128字节,通过前128字节来判断文件的格式;
		   格式有ELF格式文件、a.out、Java程序、以#!开头的脚本程序.
		3>.搜索匹配装载处理过程:通过上一步判断头部的魔数确定文件格式,然后匹配合适的可执行文件装载处理过程;ELF可执行文件对应load_elf_binary()装载处理函数;a.out可执行文件对应load_aout_binary();脚本程序对应load_script()
		4>.装载执行ELF可执行文件的过程:
			1>.读取ELF文件的Header检查文件的有效性.
			2>.读取ELF文件的Program Header Table中读取每个段的虚拟地址、文件地址、属性等.
			3>.根据 Program Header Table 将ELF文件映射至内存.
			4>.查找ELF文件的.interp节找到动态链接器(Dynamic Linker)的位置,并启动动态链接器
			5>.动态链接器获得控制权后，开始执行一系列初始化操作
			6>.动态链接器根据当前的环境参数，对可执行文件进行动态链接工作
			7>.控制权被转交到可执行文件的入口main函数,程序开始正式执行.
	2>.源文件到可执行文件的过程:预处理,编译,汇编,链接4步.
			1>.预处理:源文件经过编译预处理得到.i文件;i文件其实就是把include头文件内容的插入,删除#define并替换宏,代码过滤.
			2>.编译:对预处理后的.i文件进行词法分析,语法分析,语义分析,以及优化后产生相应的.s汇编文件.
			3>.汇编:把.s汇编文件中的汇编代码翻译成目标机器指令生成.o或.obj目标文件.
			4>.链接:把每个独立目标文件按照它们的要求将它们组装起来,产生.out可执行文件;链接主要解决的是源代码之间的相互依赖问题.
				1>.静态链接:将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中.
				2>.动态链接:在程序编译时并不会被连接到目标代码中,而是在程序运行是才被载入.
	3>. 进程的8种终止方式:
			●从main函数返回;
			●调用exit;
			●调用_exit/_Exit;
			●最后一个线程退出;
			●从最后一个线程调用pthread_exit;
		另外3种为异常终止分别为:
			●调用abort;
			●收到一个信号;
			●最后一个线程处理取消请求.
	4>. atexit函数用于注册进程退出时的回调函数(最多可注册32个);在main函数或调用exit未返回时内核调用注册的回调函数.
		●注册的回调函数的调用次序与注册次序相反.
		●但通过调用_exit/_Exit退出及由信号触发的进程退出不会调用atexit注册的回调函数.
	5>. main参数列表:argc是命令行参数的个数;argv是参数列表;
		env是环境变量列表,作用不大;可通过全局环境变量environ访问;也可通过getenv/setenv函数访问设置环境变量.
	6>. C程序的存储空间分布/进程存储空间布局/进程内存布局:正文段,初始化数据段,未初始化数据段(bss段),栈,堆这5个区.
		1>.正文/代码段:存放由CPU执行的机器指令,此段以只读的方式加载指令.
		   初始化数据段:存放显式初始化的全局变量和静态变量.
		   未初始化数据段:存放未显式初始化的全局变量和静态变量.
		   栈:存放局部变量以及每次函数调用时所需保存的信息.
		   堆:运行时进行动态内存分配.
		2>.代码段和初始化数据段的内容都在磁盘上的可执行文件中,由系统从可执行文件中加载进内存.未初始化数据段的内容不在磁盘上的可执行文件中,由内核初始化.
		   未初始化的全局变量或静态变量只在ELF文件的段表中记录名字,类型,大小,偏移量等.
		   e.g., 程序汇总定义两个全局数组一个初始化另一个不初始化,初始化的数组占用ELF文件的大小,加载时被加载到初始化数据段,未初始化的数组不会增加ELF文件的大小,被加载到bss段.
		3>.正文段和数据分开的原因:便于内存管理,防止指令被改写.
	7>. malloc函数:分配指定字节数的内存;内存中的初始值不确定. 由free函数释放内存
		calloc函数:为指定数量指定长度的对象分配内存;内存中的每一位都被初始化为0. 由free函数释放内存
		realloc函数:增加或减少以前分配的内存的长度,当增加长度时可能需要将以前分配内存中的内容移到另一个足够大的区域,以便在尾部增加内存,新增区域的初始值不确定. 由free函数释放内存
		sbrk()系统调用扩充进程的堆存储段,内存分配函数都是基于此系统调用.
	8>. getenv函数获取系统中的环境变量值.
		putenv/setenv设置环境变量.
		unsetenv删除环境变量.
		clearenv删除所有环境变量(仅linux支持).
	9>. goto跳转不能跨越当前函数(只能在当前栈帧内跳转);setjmp/longjmp用于夸调用栈的跳转.
		setjmp函数设置希望返回到的位置.
		longjmp函数执行跳转,跳转到指定位置的栈变量不确定是否回滚.
	10>. getrlimit/setrlimit用于获取或设置进程的限制值,只有root用户可以提高限制值.

第八章:进程控制★★★
	1>. PID为0的进程通常是调度进程,为1的通常是init进程.
	2>. getpid/getppid分别用于获取进程ID和获取父进程ID.
	3>. fork函数创建一个调用进程的副本(子进程);此函数分别在父进程和子进程各返回一次,也就是子进程是从fork调用处开始往后执行的.在子进程中fork返回0,父进程中fork返回子进程ID.
		fork之后子进程并不复制父进程的完全副本,而是采用写时复制技术,内核将进程空间的访问权限改为只读,当子进程和父进程其中之一修改某一区域时,内核才为修改区域的内存制作一个副本.
		fork之后父子进程的执行次序是不确定的,取决于内核调度算法.
	4>. 父进程所有打开的文件描述符多被复制到子进程,就像执行了dup函数;父子进程每个相同的文件描述符共享同一个文件表项,意味着他们使用的是同一个文件偏移量.
		子进程继承的属性有:实际用户/组ID,有效用户/组ID,附属组ID,进程组ID,会话ID,控制终端,设置用户ID标志,当前工作目录,文件模式创建屏蔽字,信号屏蔽字,已打开文件的文件描述符标志(clsoe-on-exec),连接的共享存储段,资源限制.
		父子进程区别:fork返回值,进程ID,父进程ID,不继承父进程设置的文件锁,子进程未处理的闹钟被清楚,子进程未处理的信号集置为空.
		fork失败的主要原因有两个:系统进程数超限;实际用户ID进程数超限.
	5>. vfork与fork不同的地方是会阻塞父进程,直到子进程调用exec或exit之后父进程才能恢复运行.如果子进程在调用这两个函数之前依赖父进程的进一步动作则会导致死锁.
	6>. 僵死进程:子进程终止但父进程尚未对其进程善后处理(获取子进程有关信息,释放他仍占用的资源)的进程; ps命令将僵死进程的状态打印为Z.
		如果父进程不等待和获取的子进程的终止状态,这些子进程终止后就会变成僵死进程.
		如果父进程提前终止,则内核检查所有进程是否是此进程的子进程,是的话把其父进程设置为init进程.
	7>. wait/waitpid函数用于父进程获取子进程的终止状态;一般在父进程接收到子进程结束信号SIGCHLD后调用.
		调用wait/waitpid时如果子进程都在运行,则阻塞;如果有子进程已终止等待父进程获取其终止状态,则取得该子进程的终止状态立即返回;如果进程没有任何子进程,也调用wait/waitpid则出错返回.
	8>. wait/waitpid的输出参数statloc用于判断进程退出的原因及是否产生了coredump文件,判断宏定义在sys/wait.h中.
		waitpid提供了非阻塞调用的参数选项.
	9>. waitid函数作用与wait/waitpid类似, 但waitid可以等待指定进程组中的任一子进程.
	10>.wait3/wait4函数是从BSD分支沿袭下来的,linux平台支持;在获取子进程退出状态的同时可以获取子进程资源使用概况(用户/系统cpu时间,缺页次数,收到信号个数等).
	11>.exec族函数功能是用磁盘上的一个新程序替换当前进程的正文段,数据段,堆段,栈段;新程序从main函数开始执行.
		exec加载新可执行文件后,由fork继承而来的文件描述符内核默认仍保持打开状态;除非对一个文件描述符设置了文件描述标志(close-on-exec).
		exec族函数总共有7个,区别是:
			1>.可执行文件的查找方式,不带p的以路径文件名为参数,带p的以文件名在PATH环境变量中查找可执行文件,带f前缀的则是使用文件描述符的版本.
			2>.新可执行文件的参数传递方式,带l的把每个参数作为独立参数一个一个传,带v的以数组传.
			3>.向新程序传递环境相关,带e的3个函数传递一个环境字符串指针数组,不带e的则使用调用进程中的全局环境变量environ为新程序复制现有环境.
	12>.setuid用于设置实际用户id,有效用户id,保存的设置用户id;当由非超级用户调用时则只会改变有效用户id.
		setgid用于设置组相关的ID与setuid类似.
		通过打开可执行文件的设置用户ID位,在exec函数中内核会修改进程的有效用户ID,并把原有效用户ID保存在保存的设置用户ID用于后续恢复权限.
		setreuid用于交换实际用户ID与有效用户ID的值;setregid与setreuid类似.
		seteuid/seteguid函数只修改有效用户ID和有效组ID.
	13>.解释器文件:是一种脚本文件,也是一种可执行文件;e.g., shell脚本,python脚本.解释器文件由解释器解释执行具体操作.
		解释器:在解释器文件中第一行叹号后绝对路径下的可执行程序,由此程序解释此行之后的内容执行具体的操作.
	14>.system函数用于执行一个字符串命令.system函数底层通过fork,exec,waitpid这三个函数实现.
	15>.accton命令用于打开或关闭会计服务;用于开启会计服务后记录进程的进程名,启动时间,用户ID,组ID,占用的cpu时间等;第一条会计记录是accton本身的记录,只有进程结束时才会增加一个会计记录,在进程退出之前相关的数据保存在进程表中.
	16>.getlogin函数用于获取运行该程序用户的登录名.
	17>.nice函数用于设置或获取当前进程的调度优先级.
		getpriority/setpriority用于获取或设置指定进程的调度优先级.当获取的是进程组的优先级时返回的是进程组中优先级最高的值
		进程优先级范围是0~(2*NZERO-1)之间;0级是最高优先级.
	18>.times(buf)函数用于获取进程及子进程相关的时间信息;返回的buf参数中包含了当前进程及子进程占用的用户cpu时间和系统cpu时间.

第九章:进程关系
	1>. 终端登录时init进程负责为每个终端设备fork一个子进程,然后子进程exec加载一个程序,该程序负责打开终端设备,后续用户通过该终端设备来与系统交互.
		当exec加载一个程序并打开终端之后,该程序提示用户输入用户名,之后再exec或者fork子进程来加载login程序进行登录,login程序负责验证密码,并通过读取配置文件来初始化用户终端环境.
	2>. 每个进程都有一个进程ID;另外每个进程都属于一个进程组.进程组是一个进程或多个进程的集合.
		每个进程组都有一个进程组ID,进程组ID等于组长进程ID;当组长进程结束之后,进程组依旧存在;
		进程组的生命周期是从进程组创建开始,直到最后一个组员离开.
		进程组最后一个组员离开的方式有两种:一是组员结束死亡;二是组员脱离当前进程组加入其他的进程组.
		getpgid函数用于获取当前进程组ID.
		getpgid函数返回指定进程的进程组ID.
		setpgid函数设置一个进程的到其他进程组,脱离当前进程组创建或加入到其他进程组.
		进程只能为自己或子进程设置进程组ID,但子进程调用exec之后就不能再设置进程组ID了.
	3>. 会话是一个或多个进程组的集合;通常是由shell将多个进程组组成一个会话.
		setsid函数用于主动创建一个新会话;调用该函数的进程不能是一个进程组的组长,否则会失败.
		非进程组组长调用setsid函数会发生3件事:
			1>.创建一个新会话,调用进程变成新会话的会话leader.
			2>.调用进程成为一个新进程组的组长;新进程组ID就调用进程的进程ID.
			3>.调用进程如果有控制终端则会失去终端.
	4>. 一个会话最多只有一个控制终端,也允许没有终端.
		控制进程:建立与控制终端连接的会话首进程;调制解调器断开连接的信号会被发送到控制进程.
		控制进程所在的进程组成为前台进程组;其他进程组则为后台进程组.
		会话中的进程组可被划分为一个前台进程组和一到多个后台进程组;如果会话有控制终端则他有前台进程组.终端输入和终端产生的信号会被发送到前台进程组的所有进程.
		tcgetpgrp(fd)函数用于获取控制终端相关联的前台进程组ID.
		tcsetpgrp(fd,pgrpid)函数用于指定会话内的前台进程组ID,fd参数为控制终端的文件描述符.
		tcgetsid(fd)用于获取会话首进程ID或会话ID(如果会话有控制终端则相当于获取控制进程ID).
	5>. 会话和进程组常常用于作业控制.
		e.g., 多个进程单独成为一个进程组可以统一开始或结束;而不受父进程shell的的控制或者影响.
		当进程组首领进程结束时进程组还是存在的,其他进程还是在运行的;但当会话首领进程结束时,会话内的所有进程都会结束.

第十章:信号★★★
	1>. 信号是软中断,它提供了一种处理异步事件的方法.
	2>. 每个信号都有一个以SIG开头的名字,信号名对应一个信号编号;不存在信号编号为0的信号. Linux,FreeBSD都支持应用程序定义的信号.
	3>. 产生信号的5种条件:
		1>.在终端中按键引发终端产生信号(e.g. ctrl+c,delete).
		2>.调用kill函数.
		3>.使用kill命令.
		4>.硬件异常产生信号.
		5>.软件条件触发信号(e.g. 套接字外带数据产生SIGURG信号,alarm定时器超时SIGALRM信号,管道读端已关闭时另一个进程再写管道产生SIGPIPE信号).
	4>. 操作系统定义了31种信号,信号的三种处理方式:
			1>.忽略信号.SIGKILL和SIGSTOP信号及硬件异常信号不能忽略,前两种用于终止进程,后者硬件异常后继续运行是未定义行为.
			2>.捕获信号;注册信号处理程序.
			3>.系统默认动作为以下三种之一:
				●忽略,大多数系统默认动作是这种.
				●终止进程.
				●终止进程加产生coredump.
		产生coredump的信号共12种(e.g., abort异常终止,硬件故障,算术异常,内存越界,无效系统调用等).
	5>. 不产生core文件的情况:
		1>.进程是设置用户ID的,而当前用户不是可执行程序的所有者.
		2>.进程是设置组ID的,而当前用户不是可执行程序的组所有者.
		3>.用户没有写当前工作目录的权限.
		4>.文件已存在且用户对该文件没有写权限.
		5>.core文件大小超过CORE_LIMITS限制.
	6>. core路径文件名通过/proc/sys/kernel/core_pattern进行配置.
		系统默认不产生core文件,通过ulimit -c unlimited命令取消限制生成core文件(当前终端中临时生效).
		/etc/security/limits.conf中修改core文件限制可永久生效.
	7>. signal函数用于捕获信号,向系统注册一个信号捕获后的信号处理回调函数.
	8>. 低速系统调用:可能会使进程永远阻塞的一类系统调用(e.g. 读管道/终端设备/网络套接字,某些写操作,某些ioctl操作,某些进程间通信函数).
		在低速系统调用阻塞期间捕获到一个信号,则此系统调用被中断返回不再执行,errno设置为EINTR.
		系统引入了被中断低速系统调用自动重启动机制,自动重启动的系统调用包括:ioctl,read,readv,write,writev,wait,waitpid这5个.
	9>. 可重入函数:被信号中断后恢复执行而没有影响,也称为异步信号安全的.
		可重入函数不能使用:
			1>全局/静态变量.
			2>.malloc/free(维护的有全局的存储区链表).
			3>.标准IO函数(标准IO库中很多实现都使用全局数据结构).
		在信号捕获处理程序中如果使用了会产生errno的函数,则应在调用这些函数前先保存errno的值,信号处理程序返回之前恢复.
	10>.递送信号:信号产生后内核在进程表中设置一个信号标志.
		信号未决的:在信号产生和内核递送信号的时间间隔中的信号状态.
		内核在递送一个信号给进程时才决定对这个信号的处理方式,所以在信号递送之前仍可以修改信号的处理动作.
		在进程解除阻塞信号之前,同一信号产生了多个,POSIX.1会对信号排队;其他的则合并,在解除信号阻塞后只递送一次.
		信号屏蔽字:当前要阻塞递送到进程的信号集,对于每个信号在信号屏蔽字中都有一位与之一一对应.
	11>.kill函数用于向某一个进程或某一进程组内所有进程发送一个信号.
		raise函数用于向调用进程发送一个信号.
	12>.alarm函数向内核注册一个闹钟,经过指定时间后产生一个SIG_ALRM信号发送给调用进程;每个进程只能设置一个闹钟,多次设置闹钟时则刷新闹钟时间,时间指定为0时则取消闹钟.
		pause函数用于挂起进程,直到捕获到一个信号;只有执行了一个信号处理程序(可以是默认的也可以是用户注册的)并从中返回时pause函数才返回继续执行.
	13>.sigprocmask函数用于获取或设置进程的信号屏蔽字.
	14>.sigpending函数用于获取当前由于被信号屏蔽字屏蔽而无法递送到进程的信号.
	15>.sigaction是POSIX标准的函数,功能类似标准库函数signal,用于设置/检查/修改信号捕获处理回调函数.
	16>.sigsetjmp/siglongjmp函数用于在信号捕获处理函数的跨栈跳转.
		引入信号相关的专用跨栈跳转函数是因为:当捕捉到信号进入信号捕捉处理函数后，此信号被自动地加到进程的信号屏蔽字中以阻止此后产生这种信号再中断该信号处理程序;临时自动修改了信号屏蔽字后使用longjmp跳出信号处理程序,进程的信号屏蔽字可能无法恢复.使用这两个信号相关跨栈跳转函数可再跳转时恢复信号屏蔽字.
	17>.sigsuspend函数在一个原子操作中设置信号屏蔽字并挂起进程,直到捕捉到一个信号且从此信号处理程序返回,sigsuspend才会返回,并且恢复信号屏蔽字到调用此函数之前的状态.
	18>.abort函数用于向调用进程(自己)发送一个SIGABRT信号使进程退出并生成coredump文件.
	19>.sleep/nanosleep/clock_nanosleep函数用于挂起调用进程直到经过参数指定的时间,或者捕获到一个信号并从信号处理程序返回,此时睡眠函数返回值是剩余未休眠的时间.
	20>.psignal/strsignal函数用于获取指定信号对应的描述信息.

第十一章:线程★★★
	1>. 线程作为CPU调度的基本单位,而进程作为资源拥有的基本单位.
	2>. 进程的优点:
			1>.进程间互相独立,互不影响其他进程的运行.
			2>.进程拥有独立的地址空间和相关资源,资源上限比线程的大.
		进程的缺点:
			1>.进程间同步比线程间同步更复杂,使用进程共享锁还需要考虑进程异常退出时,占用的锁如何恢复状态.
			2>.进程间数据传递只能通过IPC,而线程间由于共享进程地址空间本能的支持.
			3>.进程切换开销比线程切换要大.
	3>. 线程的优点:
			1>.可采用同步模式,程序逻辑和控制方式简单.
			2>.进程内的多个线程具有相同的内存空间和文件描述符,对资源的访问比较容易.
			3>.占用的系统资源少,共享进程地址空间.
			4>.线程切换对CPU的损耗较小.
		线程的缺点:
			1>.线程崩溃进程内的其他线程也跟随进程一起结束.
			2>.线程之间访问同一个数据需要数据同步机制避免冲突.
			3>.线程切换虽然比进程切换消耗小的多,但活跃线程数量太多时一样消耗比较大.
	4>. 每个进程都有一个进程ID,在整个系统中是惟一的;每个线程也都有一个线程ID,线程ID在进程内是唯一的.
		不同平台上线程ID的数据类型pthread_t是不同的,通过函数pthread_equal来比较两个线程是否一样.
		pthread_self函数用于获取自身的线程ID.
	5>. pthread_create函数用于创建一个线程.
	6>. 线程可以通过3种方式退出:
		1>.线程函数return.
		2>.被同一进程内的其他线程取消.
		3>.线程调用pthread_exit函数(pthread_exit可以指定一个信息由外部的pthread_join函数来获取).
	7>. pthread_join函数用于等待线程终止;通过输出参数可以获取线程的终止状态.
	8>. pthread_cancel函数用于取消指定的线程;取消作为一个请求可以被忽略或做一些额外工作后再取消.
		pthread_cancel的调用是直接返回的并不关心目标线程是否真正退出的结果.
	9>. pthread_cleanup_push函数用于注册线程退出时需要调用的函数(类似进程退出时atexit函数),可以注册多个线程退出回调函数;线程退出回调保存在栈中,触发时调用次序与注册次序相反.
		pthread_cleanup_pop函数用于调用一个回调函数并从栈中弹出这个回调;如果参数为0则只弹栈不执行回调函数.
		线程处理回调函数被触发的3种情况:
			1>.调用pthread_cancel函数取消此线程时.
			1>.线程自身调用pthread_exit函数.
			1>.调用pthread_cleanup_pop函数.
	10>.线程刚创建完成时是未分离状态的,未分离的线程终止状态会一直存在直到对该线程调用pthread_join函数.
		pthread_detach函数用于分离线程.
		如果线程已分离,在线程终止时线程所对应的内核中的资源会被自动回收. 对已分离的线程调用pthread_join是未定义行为应避免.
	11>.当多个线程同时读写同一个变量时将带来数据一致性问题.
	12>.线程同步方式:互斥量,读写锁,条件变量,自旋锁,信号量,屏障.
	13>.互斥量:同一时刻只有一个线程能获取到锁,其他线程则处于阻塞状态等待锁被释放.
		死锁原因:
			1>.在未释放锁时尝试对此锁第二次加锁.
			2>.一个线程在占用第一把锁的同时尝试对第二把锁加锁时被阻塞,另一个线程在占用第二把锁的同时尝试对第一把锁加锁,此时两个线程都产生死锁.
		避免死锁的建议:
			1>.避免嵌套加锁(锁中套锁).
			2>.无法避免嵌套锁的话,则使他们具有相同的加锁顺序,以避免相互占用又竞争对方的锁.
			3>.无法保证加锁顺序时,使用超时锁或非阻塞的尝试锁,超时或尝试失败时先释放自己占用的锁,为对方开绿灯.
		pthread_mutex_trylock函数用于尝试加锁,加锁成功返回成功,加锁失败则立即返回而不阻塞.
		pthread_mutex_timedlock函数用于加锁成功时返回成功,等待指定时间还无法加锁则返回失败,避免阻塞当前线程.
	14>.读写锁:同一时刻只有一个线程可以占用写模式的锁,但多个线程可以同时占有读模式的锁.
		读写锁的实现通常优先写模式加锁,而阻塞同一时刻读模式加锁请求.
		读写锁适用于读操作频率高于写模式操作的场景,可提高并发性.
	15>.条件变量:用于判断一个条件是否满足,而不是判断非真即假的状态(互斥锁提供互斥机制,条件变量提供信号机制).
		条件变量与互斥锁的应用场景:
			互斥锁用于防止冲突,强调对资源的保护.而条件变量主要用在检查某一个条件是否满足来避免轮训式加解锁来判断条件,完全可以用互斥锁来代替条件变量只是互斥锁在这种场景下比较耗费cpu资源.
		条件变量应用场景例子:
			城际快递车是否应该发车,只有装满了车厢或收一天的包裹才能发车.使用条件变量的话不用每收一个包裹就来问一遍可以发车吗?而是够一车或够一天有人来通知你装车发送.
		为什么条件变量要搭配互斥锁使用:
			防止在阻塞等待之前,另一个线程发送了信号,这样第一个线程就等不到这个通知了.如果阻塞等待之前加了互斥锁,其他线程在发送条件满足的通知前必须要先获取锁才能发送信号,这样等待条件满足的线程就不会错过这个信号了.
		条件变量的使用:
			创建一个互斥锁和条件变量, 在调用条件变量pthread_cond_wait之前对mutex加锁,当条件变量处于等待状态,线程因阻塞放到等待队列后自动释放mutex的锁.在需要触发条件之前加锁确保其他线程处于等待条件变量状态.当触发条件变量后,pthread_con_wait返回后会自动对mutex加锁.
	16>.自旋锁:不会挂起线程,一直占用cpu自旋忙等(死循环尝试加锁).
		自旋锁与互斥锁的区别:自旋锁是忙等加锁失败一直占用cpu请求加锁直到加锁成功之后返回;互斥锁是挂起线程等待,加锁失败会进行上下文切换,将自己加到等待队列直到其他线程释放锁并唤醒,期间cpu可以执行其他任务.
		自旋锁适用于替代上下文切换消耗过多cpu的情况,加锁次数多且占用锁时间短的场景.
	17>.信号量:第十五章-10节
	18>.屏障:用于关注多个"条件"同时满足的情况;类似于golang的WaitGroup.
		e.g., 当初始化屏障资源数为8,每次调用pthread_barrier_wait函数会使资源数减一,资源数不为0则阻塞,直到资源数降为0时所有barrier_wait函数才会返回.

第十二章:线程控制★★★
	1>. 线程属性:分离状态,线程栈大小,线程栈起始地址,线程栈警戒缓冲区大小.
		线程属性可以在创建线程时pthread_create函数中传入,也可以线程创建成功后单独设置.
		pthread_attr_init/pthread_attr_destroy函数分别用于初始化一个系统默认值的线程属性结构和销毁属性结构.
		pthread_attr_getdetachstate/pthread_attr_setdetachstate函数用于获取或设置线程的分离状态.
		pthread_attr_getstack/pthread_attr_setstack函数用于获取或设置线程栈的起始地址;当进程栈空间耗尽时可通过malloc分配堆内存设置给线程栈起始地址当做线程栈来使用.
		pthread_attr_getstacksize/pthread_attr_setstacksize函数用于获取或设置线程栈的大小.
		pthread_attr_getguardsize/pthread_attr_setguardsize函数用于获取或设置线程栈警戒线大小;线程栈警戒线用来避免栈溢出时的扩展内存大小.
		linux/mac线程栈默认大小为4KB,通过`ulimit -s [大小]`命令查看或设置.
	2>. 互斥锁属性: 进程共享, 健壮属性, 类型属性.
		1>.进程共享属性:在进程间共享内存中分配的互斥锁,设置此互斥锁属性为进程共享用于进程间同步.需要设置共享属性可能是因为内核在加解锁时需要跨进程处理,作为一个标记.
		2>.健壮属性:健壮属性是作为进程共享属性的补充,用于决定持有互斥锁的进程未解锁退出时,解决互斥锁的状态恢复问题.
		   1>.未设置健壮属性时,进程A在未解锁状态下异常退出,其他进程会一直阻塞.
		   2>.设置健壮属性时,A进程未解锁异常退出,其他进程的pthread_mutex_lock调用会返回EOWERDEAD,此时调用pthread_mutex_consistent函数重置互斥锁状态,然后就可以正常请求加锁了.
		3>.类型属性:类型属性控制着互斥量的锁定特性.
		   1>.标准类型,不做任何错误检查和死锁检查.
		   2>.差错检查类型,提供错误检查机制.对未加锁的锁解锁,跨线程解锁(别的线程加锁本线程解锁),重复加锁,重复解锁这几种操作均会返回错误.
		   3>.重复加锁类型(有的人也称之为递归锁),在同一个线程内允许对互斥锁多次加锁,当然也需要对应次数的解锁才会真正解锁.
		   4>.默认类型,linux中把他实现为标准类型.
		pthread_mutexattr_init/pthread_mutexattr_destroy用于创建默认互斥锁属性结构和销毁.
		pthread_mutexattr_getpshared/pthread_mutexattr_setpshared函数用于获取或设置进程共享属性.
		pthread_mutexattr_getrobust/pthread_mutexattr_setrobust函数用于获取或设置健壮属性.
		pthread_mutex_consistent函数用于设置过健壮和进程共享属性的互斥锁的持有进程异常退出后,其他进程通过判断错误码恢复进程共享互斥锁的状态.
		pthread_mutexattr_gettype/pthread_mutexattr_settype函数用于获取或设置类型属性.
	3>. 读写锁只支持进程共享属性,与互斥锁的进程共享属性一样.
	4>. 条件变量支持进程共享属性和时钟属性;进程共享属性与前两者一样,时钟属性用于指定超时时间采用哪种时钟时间.
	5>. 屏障也只支持进程共享属性,与前几个一样.
	6>. 可重入函数:指一个函数在相同的时间点可以被多个线程安全的调用,也就是不依赖外部全局的或静态的数据,也被称为线程安全的.
	7>. 线程特定数据:也称为线程私有数据.
		线程特定数据的作用:
			1>.防止某个线程的数据与其他线程的数据相混淆且提供额外的保护.
			2>.让基于子进程的接口适应多线程环境(e.g. errno).
		在分配线程特定数据之前需要创建与该数据关联的键,这个键被进程内所有线程使用,使用这个键获取线程特定数据的访问.
		每个线程都维护了一个键与指针的表,创建键之后表中键对应的指针为空,线程通过pthread_setspecial函数把数据与键关联起来.
		pthread_key_create函数创建一个键,并指定此键所关联数据的析构函数;在线程退出时用于释放与该键关联的数据.
		pthread_key_delete函数用于取消键与数据的关联关系.
		pthread_key_setspecial函数用于把线程特定数据与一个已经创建好的键关联起来.
		pthread_once函数用于保证指定的函数只被调用一次, 上边创建键时可用于保证键只被创建一次.
	8>. 线程有两个额外的属性不包含在pthread_attr_t中,分别是:可取消状态,可取消类型.
		1>.可取消状态:
			ENABLE(默认):调用pthread_cancel线程取消请求,会根据可取消类型处理取消请求.
			DISABLE:取消请求被挂起直到可取消状态再次变为ENABLE,线程才会根据可取消类型处理取消请求.
		2>.可取消类型:
			推迟取消(默认):收到取消请求后只有到达一个取消点才能处理取消事件.
			异步取消:只要收到取消请求就立即处理取消请求而不必等到达取消点.
		pthread_setcancelstate函数用于设置线程的的可取消状态.
		pthread_setcanceltype设置收到取消信号后立即执行取消动作还是继续运行至下一个取消点.
		pthread_testcancel函数用于设置自己的取消点;部分标准函数内含取消点.
	9>. 每个线程都有自己的信号屏蔽字,但信号处理函数是进程中所有线程共享的,当线程修改了某个信号的处理函数后所有线程共享这个改变.
		进程中的信号是递送到单个线程的,硬件故障或定时器产生的信号被递送到引起该事件的线程中,其他信号则被随机递送到任一线程.
		闹钟定时器是进程资源,进程中的所有线程共享一个闹钟定时器,所以进程中的多个线程不能互不干扰地使用闹钟定时器.
		pthread_sigmask函数用于设置线程的信号屏蔽字.
		pthread_kill函数用于向指定线程发送一个信号.
		sigwait函数用于等待线程的信号.
	10>.在有多个线程的进程中调用fork时,只有调用fork的线程被复制到子进程中,但父进程的互斥锁,条件变量,打开的文件描述符等都被继承下来了.
		进程中某个线程fork后,父进程中的其他线程占有锁,子进程同样占有这些锁,但子进程可能不含有包含锁的线程副本而导致无法解锁.
			1>.子进程立即exec覆盖子进程地址空间;但有些应用场景不能exec.
			2>.pthread_atfork函数建立fork处理程序.
		pthread_atfork(preparefn,parentfn,childfn)函数用于注册3个函数,在父进程调用fork后子进程还未创建时先调用preparefn获取所有锁,然后在父进程调用parentfn函数处理锁,在子进程调用childfn函数处理锁.
		fork后只在父进程中存在的线程的线程特定数据也被继承到子进程,然而在子进程中不会调用线程特定数据的析构函数导致内存泄漏.因此在多线程的进程中调用fork后应该在子进程中调用exec载入另一个可执行文件覆盖当前子进程存储空间.
	11>.pread/pwrite函数把读写和设置偏移量两个动作作为一个原子操作进行读写,防止一个线程在设置偏移量和读之间,偏移量被另一个线程修改的尴尬.

第十三章:守护进程
	1>. 守护进程没有控制终端,在ps命令中TTY列显示为问号;CMD列带[]的为内核守护进程,不带[]的为用户守护进程.
	2>. 守护进程6条规则:
		1>.调用umask将文件模式创建屏蔽字设置为0,因为继承得来的文件模式创建屏蔽字可能拒绝某些权限.
		2>.调用fork然后使父进程退出,使子进程不是一个进程组的组长ID,只有这样才能创建一个会话.
		3>.调用setsid创建一个新会话,然后此进程会成为新会话的首进程,也成为新进程组的组长进程,也没有了控制终端.
		4>.将当前目录改为根目录.
		5>.关闭相应的文件描述符.
		6>.打开/dev/null使其具有文件描述符0,1,2;这样任何一个试图读标准输入,写标准输出或标准错误的函数都不会有任何效果.
	3>. 守护进程日志接口:
		1.内核守护进程可以调用log函数,任何一个进程通过打开然后读/dev/klog设备就可以读取这些日志.
		2.用户进程调用syslog函数产生日志消息,这使消息发送至UNIX域数据报套接字/dev/log.
	4>. 用文件记录锁的方式可实现单例守护进程,避免多个守护进程实例同时运行.
	5>. 守护进程遵循下列通用惯例:
		1>.守护进程如果使用锁文件,通常存放在/var/run目录中.
		2>.守护进程的配置文件通常存放在/etc目录中.
		3>.守护进程通常由系统初始化脚本启动(e.g. /etc/rc*或者/etc/init.d/*中).
		4>.守护进程通常需要在/etc/inittab中添加respawn记录项,以使守护进程退出后可以自动启动该守护进程.upstart事件驱动机制的配置文件在/etc/init目录下.
		5>.守护进程通常捕获SIGHHUP信号,当收到信号时重新读取配置文件,应用新的配置信息.

第十四章:高级IO★★★
	1>. 非阻塞IO的两种方式:
			1>.使用open函数打开文件时指定O_NONBLOCK标志,对返回的文件描述符进行操作时就是非阻塞操作了.
			2>.使用fcntl对一个文件描述符设置O_NONBLOCK文件状态标志.
	2>. 记录锁:阻止多个进程同时修改同一文件区域,以避免多个进程同时读写造成冲突或数据不一致问题.
		fcntl函数用于对文件或文件某一区域添加记录锁,还可以锁住文件尾可能追加的区域,记录锁的用法与读写锁类似.
		记录锁只能作用于进程之间,同一进程内重复加锁时覆盖之前的锁(无论现在加的锁的类型与之前已加锁的类型是否相同).
		如果两个进程相互等待对方持有的记录锁且不释放自己持有的记录锁,则两个进程处于死锁状态.
	3>. 记录锁的继承与释放:
		1>.当进程终止时或文件描述符被关闭时,文件上的记录锁会被自动释放.
		2>.fork产生的子进程不会继承文件描述符上的记录锁,如果子进程需要记录锁那么自己再加锁.
		3>.执行exec后,新程序可以继承原执行程序的锁,但如果对有记录锁的文件描述符设置了执行时关闭标志,那么exec后文件描述符将被关闭同时也会关闭相应文件的所有记录锁.
	4>. 当对文件的一部分加记录锁时,传给内核的相对偏移量会被转换成绝对偏移量保存,当解锁时如果文件尾有变化则会解锁原文件尾的锁发生错误,因为锁记录的是绝对偏移量范围,在这种情况解锁时需要用户根据自己代码调整解锁参数.
	5>. 建议性锁:是一个进程用记录锁将文件锁住,另一个进程可以直接操作正在被其他进程锁住的文件,因为记录锁是"独立"于文件的只用于检测文件是否被加锁,内核不会阻止其他进程的写入操作.
	6>. 强制性锁:强制性锁会让内核检查每一个 open 、read 和 write ，验证调用进程是否违背了正在访问的文件上的一把锁.
		开启强制性锁机制方法:对一个文件打开其设置组ID位并且关闭其执行位.
	7>. IO多路复用:一个线程监听多个IO文件描述符,一旦有就绪事件则通知应用程序进程相应处理.
		文件描述符到达文件尾是一个读事件,而非异常事件.
		1>.select用法:创建读/写/异常事件的三个描述符集,然后作为参数调用select等待事件发生. select函数可以指定超时返回时间.
			如果描述符集中的一个套接字或描述符设置为非阻塞模式,对select没有任何影响.
			FD_ISSET:测试fd是否已添加到描述符集.
			FD_CLR:从描述符集删除fd.
			FD_SET:添加fd到描述符集.
			FD_ZERO:清空描述符集.
		2>.poll用法:与select类似,不同的是不用三个描述符集,而是一个pollfd类型数组,结构体内部指定关注的事件类型.同样描述符是否为非阻塞模式对poll没有任何影响.
		3>.epoll用法:创建epoll对象,通过epoll对象添加文件描述符及对应关注事件结构体到内核事件表,然后调用epoll_wait等待事件发生.
			epoll_create函数用于创建一个epoll对象(在内核创建文件描述符集合及就绪链表).
			epoll_ctl函数用于添加/移除fd在内核事件表(不仅将fd放到内核中的红黑树上,同时也注册了回调函数,内核在检测到某文件描述符可读/写调用回调函数,该回调函数会把文件描述符放在就绪链表中).
			epoll_wait:等待文件描述符的事件发生,其实只用观察就绪链表中有无数据即可,最后将就绪链表拷贝到数组并返回就绪的数量. 内核将就绪的文件描述符放在传入的数组中,所以用户只需遍历依次处理即可.继续重新监听时无需把用户态文件描述符拷贝到内核空间了.
			epoll的LT和ET模式:跟tcp与udp对待数据发送一样
				LT模式:即水平触发(默认的工作方式),当epoll_wait检测到有事件发生并通知应用程序后,如果应用层没有处理该事件并重置对应fd上的触发状态,则下次调用epoll_wait时,还会通知此就绪事件直到应用层处理了.
				ET模式:即边缘触发(高效工作模式),当epoll_wait检测到有事件发生并通知应用程序后.无论应用层处理不处理fd上的就绪事件,只会通知一次;因此效率更高
				当为文件描述符往内核事件表添加 EPOLLET 事件时,epoll将以ET模式来操作该文件描述符.
			epoll事件类型:
				EPOLLIN:新连接或可读数据.
				EPOLLOUT:可写数据.
				EPOLLHUP:对端连接关闭时触发(无需显式指定).
				EPOLLRDHUP:对端连接断开会触发.
				EPOLLERR:写已关闭的套接字时触发(无需显式指定).
	8>. epoll优点:
			1>.每次调用epoll_wait不用把描述符集合从用户空间拷贝到内核空间;select和poll需要.
			2>.epoll在内核中采用回调方式检测就绪事件;而select和poll在内核中采用轮训方式检测就绪事件,随着描述符增多效率会线性降低.
			3>.每次epoll_wait返回后不用遍历文件描述符集合检查哪个就绪,因为直接返回了就绪的描述符集合直接遍历处理即可;而select和poll需要遍历检查状态再处理.
			4>.epoll支持边缘触发(ET模式)比较高效,其他两种只支持水平触发LT.
		epoll缺点:
			监视的文件描述符数量较少,select与epoll性能差别不大,且select API简单易用,是POSIX标准接口移植性好.
	9>. aio_read/aio_write是POSIX的异步IO函数,提供对单个文件描述符的异步IO操作,由参数指定当事件发生时通过信号通知或通过回调函数通知.
	10>.readv/writev函数用于在一次函数调用中读或写多个非连续缓冲区,避免多次调用.
	11>.readn/writen函数用于读写指定的字节数,并内部处理一次读写字节数小于要求的字节数的情况;如果一次读写字节数小于要求字节数内部将多次读写直到读写了要求的字节数为止.
	12>.文件内存映射/存储映射:将磁盘文件映射到存储空间的一个缓冲区上,当从缓冲区中取数据相当于读文件中的相应字节,把数据写入缓冲区相应字节就自动写入文件.
		mmap函数用于把一个文件映射到一个存储区域中. 子进程会通过fork继承存储映射区,进程终止时会自动解除存储映射区的映射.
		mprotect函数用于修改一个现有内存映射区的权限(可读、可写、可执行等).
		msync函数用于共享映射中的页已经修改时调用msync将页写入到磁盘文件中.
		munmap函数用于主动解除存储映射区.
	12>.linux平台read/write和mmap/memcpy之间性能差距不大,read/write稍优;但mmap/memcpy方式的时钟时间要长的多,可能是需要较长时间等待IO完成.

第十五章:进程间通信★★★
	1>. IPC是各种进程间通讯方式的统称;包括:匿名管道PIPE,命名FIFO,消息队列,信号量,共享存储,网络套接字,本地套接字.
		另外`linux系统信号`及`文件记录锁`也可以用来进程间通信.
	2>. 匿名管道PIPE,特点有:
			1>.只能用于具有公共祖先的进程间通信.
			2>.部分系统中是半双工管道.
			3>.进程退出PIPE会被自动删除.
		pipe(int fd[2])函数用于创建匿名管道,fd[0]为读而打开,fd[1]为写而打开(e.g., fork后父进程关闭管道的读端fd[0],子进程关闭写端fd[1],这样父进程发送数据到子进程).
		当读一个写端已被关闭的管道时,在所有数据都被读取后read返回0,表示文件结束.
		当写一个读端已被关闭的管道时,则产生信号SIGPIPE;如果忽略该信号或者捕捉该信号并从其信号处理程序返回,则write返回−1且errno设置为EPIPE.
	3>. popen函数用于创建一个子进程并在子进程中exec执行一条命令,并返回一个读或写的标准IO流指针.
		pclose函数用于关闭popen返回的标准IO流并等待子进程结束,然后返回子进程终止状态.
	4>. 命名管道FIFO,特点有:
			1>.用于同一台主机内不相关的进程之间交换数据.
			2>.FIFO是一种文件类型,创建FIFO类似于创建文件,FIFO的文件名存在与文件系统中.
			3>.进程退出FIFO会被自动删除.
		FIFO命名管道的使用方式:
			1>.用mkfifo/mkfifoat函数创建命名管道.
			2>.然后要用open函数打开它.
			3>.通过read/write进行读写.
		如果以只读模式open命名管道时要阻塞到另一进程以写模式打开此命名管道.
		如果指定了非阻塞标志则以只读模式open立即返回,如果没有进程为读而打开命名管道,那么以只写模式open将返回-1.
	5>. 有三种XSI IPC分别是:消息队列,信号量,共享存储.
		IPC符标识:在内核中用以标识IPC结构,在内核中此标识符是连续递增的,直到达到最大值才回转到0.
		IPC的键:键作为IPC结构的外部命名方案用于使多个合作进程能够在同一IPC对象上汇聚.
		ftok函数使用路径名和ID产生一个键.
		msgget/semget/shmget三个函数分别用创建IPC结构或引用一个现有的IPC结构.
	6>. XSI IPC优点:他们是可靠的,流控制的以及面向记录的.
		XSI IPC缺点:
			1>.进程终止不会删除IPC对象及已写入未被读取的消息,直到:
				1>.消息被读取并显式删除此对象.
				2>.icprm命令此对象.
				3>.正在自举的系统删除消息.
			2>.由于没有文件描述符,需要使用新增的独立系统调用来访问或修改XSI IPC.
			3>.无法使用IO多路复用,多个XSI IPC对象很难统一管理起来.
	7>. XSI消息队列:由标识符标识存储在内核中的消息的链表.
		msgget函数通过key创建或引用一个现有消息队列,返回消息队列ID.在创建时第一个参数为已经生成的key第二个参数必须指明为IPC_CREAT;在引用时第二个参数必须不指定.
		msgctl函数通过队列ID获取消息队列状态,设置消息队列属性,删除消息队列及队列中的数据.
		msgsnd函数通过队列ID将消息放到消息队列中.
	8>. XSI信号量:是一个计数器用于为多个进程提供对共享数据的访问.它其实是同步原语而不是IPC,常用于共享资源(e.g., 共享存储段)的同步访问.
		当访问资源前先测试信号量的值,如果大于零可以使用该资源并使信号值减一,表示使用了一个资源单位.如果信号量的值为0则使进程阻塞直到值大于1.
	9>. XSI共享存储(共享内存):允许两个或多个进程共享一个给定的存储区,由于没有数据传递复制所以是最快的IPC.
		XSI共享存储与文件内存映射(mmap)的区别是XSI IPC没有对应的磁盘文件,使用的是内存匿名段.
		shmget函数用于创建或获取一个现有的共享存储,返回标识符ID.
		shmctl函数用于设置/获取属性,删除共享存储段,对共享存储段加锁/解锁.
		shmat用于将共享存储连接到自己的地址空间中.
		shmdt用于从自己的地址空间分离共享存储(与shmat相对).
	XSI消息队列/信号量/共享内存三种IPC使用时须指定一个ID值,该id通常通过ftok函数得到.
	10>.POSIX信号量:作用和XSI信号量一样,但解决了XSI信号量的几个缺陷:
			1>.POSIX信号量性能更高,在linux平台使用的是文件内存映射实现的,性能提升94%.
			2>.接口简单,没有信号量集,使用文件系统实现.
			3>.删除POSIX信号量时其他操作能继续正常工作直到该信号量的最后一次引用被释放,而XSI信号量被删除时其他操作会失败.
		POSIX信号量分为命名信号量和匿名信号量:
			1>.匿名信号量:只存在与内存中,所以必须是同一进程中的不同线程间使用.
			2>.命名信号量:可以被任何已知它们名字的进程中的线程使用.
		sem_open函数用于创建或打开一个信号量.
		sem_post函数发送一个信号.
		sem_wait/sem_timedwait/sem_trywait函数用于等待信号量有可用资源,信号量值为0时阻塞, 大于0时执行减一操作并返回.
		sem_close函数用于释放信号量.
		sem_unlink函数用于关闭最后一个信号的引用时销毁.
	11>.信号:内核提供的信号无法传递数据,而且信号只有30种,用于进程间通信时只适用于简单的事件通知场景.
	12>.文件记录锁:利用文件锁可实现多个进程对于某个资源的排队请求,也不能用来传递数据.
		通过文件记录锁可实现进程间读写锁的功能.
	13>.开发中IPC应尽可能避免使用XSI消息队列和XSI信号量,而应考虑使用管道和记录锁,它们使用起来更方便,共享存储也可以.

第十六章:网络套接字★★★
	1>. 套接字是通信端点的抽象,也被视为一种文件描述符;许多文件IO的函数也可以用于处理套接字.
	2>. 创建套接字时的参数:
			domain域:
				AF_INET:IPv4协议
				AF_INET6:IPv6协议
				AF_UNIX:本地套接字
			type类型:
				SOCK_DGRAM:数据报对应UDP
				SOCK_STREAM:流式对应TCP
				SOCK_SEQPACKET:可靠数据报对应SCTP
				SOCK_RAW:是ip数据报对应IPPROTO_RAW
			protocol协议:
				IPPROTO_TCP
				IPPROTO_UDP
				IPPROTO_SCTP
				IPPROTO_RAW:直接访问的网络层,传输层(TCP,UDP)被绕过了,需要自己构建协议头.
		●shutdown函数用于关闭套接字双向传输中的一个方向(关闭读端或写端).
		●close函数关闭套接字,要直到关闭了最后一个引用它的文件描述符才会释放这个套接字.
	3>. socket使用IP+端口来标识特定进程(内核把网卡收到数据抛到哪个进程).
	4>. 网络字节序是大端字节序,也是人类从左到右的阅读顺序.
		linux是小端字节序.
	5>. inet_ntop/inet_pton函数用于二进制的网络字节序的int型地址和字符型地址之间的转换.
	6>. getaddrinfo函数将一个主机名和一个服务名转换成一个地址;主机名是一个域名或字符型IP地址,服务名是端口号或者http,ftp之类的名字.
	7>. getnameinfo函数将一个地址转换成主机名和服务器名.
	8>. bind函数将套接字和一个本地IP和端口绑定起来;ip指定为INADDR_ANY的话套接字被绑定到主机上所有网络接口上.
		getsockname函数获取绑定到套接字上的本地地址信息.
		getpeername函数获取套接字上的对端地址信息.
	9>. connect函数用来发起TCP连接,linux中connect失败时重连可重复使用同一个套接字,FreeBSD和MacOSX中connect失败socket状态变成未定义的,重连时必须重新打开一个套接字.
		UDP协议使用connect相当于设置socket对端的目的地址,在发送报文时可不再提供对端地址,同时也增加了只能接收指定地址来的数据的限制.
	10>.listen函数用于宣告开始接收连接请求,backlog参数指定未完成的连接请求队列的长度.
	11>.accept函数用于在开始监听之后,阻塞等待获取连接请求并建立连接.
		accept返回的新socket与传递进去的原始监听socket具有相同的类型和地址族,原始socket保持监听状态继续接收其他连接请求.
		如果原始监听socket设置为非阻塞模式,accept时没有连接请求时返回-1.
		监听套接字可以使用IO多路复用等待连接请求,连接请求以可读事件出现.
	12>.send/recv函数用于已绑定地址的TCP或UDP套接字收发数据.send返回成功并不代表对等端接收到了数据,只表示数据被无误的发送到了网络驱动程序上.
		sendto/recvfrom函数用于未绑定对端地址的UDP套接字收发数据.
		sendmsg/recvmsg函数用于收发多个缓冲区数据或辅助数据.参数msghdr各成员作用:
			msg_name/msg_namelen对端地址信息,类似sendto/recvfrom中的地址参数.
			msg_iov/msg_iovlen是多个缓冲区的组数和数组长度.
			msg_control/msg_controllen指定可选的辅助数据的位置和大小,接收时是结果参数.
		文件IO接口(write,read等)也可用于套接字,但socket专属接口可以指定标志参数:
			MSG_CONFIRM:提供链路层反馈以确保地址映射有效
			MSG_DONTWAIT:非阻塞操作,等价于使用O_NONBLOCK.
			MSG_MORE:延迟发送以写入更多数据.
			MSG_NOSIGNAL:不产生信号.
			MSG_OOB:发送/接收外带数据.
			MSG_PEEK:只返回数据包内容而不真正取走数据.
	13>.UDP报文长度通常为65507=65535-8-20字节,超过最大报文长度send失败.
		TCP不限制单次发送最大长度,超过MTU长度在底层分片传输完全部数据才返回.
		TCP分片发生在传输层(TCP自己这层),UDP分片发生在网络层(IP层).
	14>.setsockopt/getsockopt函数用于查询或设置socket的选项.
		SO_BROADCAST:广播数据报
		SO_REUSEADDR:如果端口忙但TCP状态位于TIME_WAIT可以重用端口;如果TCP状态位于其他状态,重用端口时依旧得到一个错误信息.SO_REUSEADDR仅表示可以重用本地本地地址和本地端口.
		SO_REUSEPORT:允许完全重复捆绑,但仅在套接口都指定了选项才行.SLB基于此实现.
		SO_RCVBUF:接收缓冲区大小.
		SO_SNDBUF:发送缓冲区大小.
		SO_RCVTIMEO:接收调用的超时时间.
		SO_SNDTIMEO:发送调用的超时时间.
		SO_KEEPALIVE:启用周期性keep-alive报文.
		SO_OOBINLINE:将外带数据放在普通数据流中.
	15>.外带数据:也称为紧急数据,外带数据以高优先级传输;由flag参数指定发送或允许接收外带数据.
		仅TCP支持外带数据.
		外带数据只能发送一个字节,超过一个字节时将最后一字节数据视为外带数据发送.
		通过设置套接字可以安排接收到紧急数据时产生一个SIGURG信号发送到指定的进程, 比如:
			fcntl(sockfd,F_SETOWN,pid)//设置套接字收到紧急数据时接收信号的进程.
			fcntl(sockfd,F_GETOWN,pid)//获取接收SIGURG信号的进程.
		当通过SO_OOBINLINE设置紧急数据在普通数据流中时,通过sockatmask函数获取当前要读的字节是否在紧急标志处.
	16>.除IO多路复用实现异步外,socket还支持基于信号的异步IO.
		启用异步IO需要两步:
			1>.fcntl(sockfd,F_SETOWN,pid)跟指定接收到外带数据发送信号一样,使信号可以被递送到指定的进程.
			2>.fcntl(sockfd,F_SETFL,flag|O_ASYNC)设置IO操作不会阻塞时发送SIGIO信号.
	17>.fcntl函数通常用于修改文件的访问控制属性.
		ioctl函数通常用于文件本身属性修改(e.g. 波特率,终端窗口大小等,这两个函数功能有重叠).

第十七章:UNIX域套接字/本地套接字
	1>. UNIX域套接字也称为本地套接字,支持流式和数据报两种接口.它是可靠的,不会丢包和出错.
		UNIX域套接字的特点:
			1>.不进行网络协议的处理,仅复制数据.
			2>.不添加或移除网络包头.
			3>.无需校验数据.
			4>.无序列包号.
			5>.无需确认反馈报文.
		socketpair函数创建一对匿名,相互连接的UNIX域套接字,起到全双工管道的作用.
	2>. bind函数绑定一个路径名使之成为命名管道.绑定后系统会在此路径下创建一个S_IFSOCK类型的文件,当其他域套接字试图绑定同一路径名时返回失败.
		关闭命名套接字并不会自动删除对应的S_IFSOCK文件,需要使用unlink函数解除链接才可以重复绑定此路径名.
	3>. UNIX域套接字可以使用标准bind/listen/accept函数,客户进程使用connect请求建立连接,在服务器进程接受了accept请求后便建立了连接.与网络套接字一样.

第十八章/第十九章/第二十章: useless chapter