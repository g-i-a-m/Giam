1>. C++是一个联邦语言 C,Object,泛型,STL
	为什么C++是一个联邦语言?
		1>.比如数组不保证内容被初始化, STL中的vector会保证初始化值.
		2>.再比如继承自普通类与继承自模板类时调用基类中成员函数编译器不会为模板基类成员的调用去基类空间搜索函数符号,从而报错
		3>.再比如调用继承自模板类内的虚函数时不会发生动态绑定,而是编译期的静态绑定.
2>. const修饰常量,指示编译器做编译期优化
	const有编译器类型检查;宏没有检查只做替换,容易诱发重复计算
	const常量在调试时有对应符号表;宏是替换所以没有
	const修饰成员函数可以与同返回值同名同参数列表可实现函数重载,只有const对象可调
	const有作用域和生命周期,宏是全局
	const常量避免频繁分配临时对象内存;	 而且基本数据类型的常量,编译器会把它放到符号表中而不分配存储空间(例外是extern其他文件中也使用的全局或静态常量);ADT/UDT的const对象则需要分配存储空间
	引申: <C++符号表>通过词法分析和语法分析,我们可以将程序转换为一棵抽象语法树
	
	enum有作用域,但也不能取地址.
	
	函数形状的宏:1>.没有参数类型检查. 2>.返回值会被强制类型转换 3>.无法取代成员this指针
	inline函数, 避免小函数频繁压栈弹栈,像宏一样.
		1>.定义在类中的成员函数默认都是内联inline的.
		2>.inline 只适合涵数体内代码简单的涵数使用.
		3>.inline 函数仅仅是一个对编译器的建议
		4>.定义放在头文件中,因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义
3>. const的右侧是类型时,指针为常量.
	const的右侧是变量名时,指向的变量是常量.
	const函数允许修改mutable修饰的成员变量.
4>. 构造函数的初始化列表在进入函数体之前就进行初始化
	初始化列表的初始化会在成员变量的默认构造函数中赋初始值,节省了赋默认值
	构造函数体内是赋值,是先调用构造再进行赋值操作
	const成员和引用必须在初始化列表初始化
	成员是以声明次序被初始化
	静态对象的析构函数会在main()退出之前调用.
	atexit(func[](){})可注册32个,回调函数调用次序与注册次序相反.
	对不同编译单元内的静态变量没规定初始化时序, 需要指定顺序时可通过单例来做.在初始化静态变量b时通过GetInstance()返回另一个静态变量a
5>. C++默认生成8个函数: 默认构造函数, 析构函数, 拷贝构造函数, 赋值操作符, 移动拷贝构造函数, 移动赋值操作符, non-const取址运算符, const取址运算符
	编译器生成的拷贝构造函数和赋值操作符的函数体内的行为是把非静态成员一一赋值.
	如果有const成员或引用成员,必须自己定义拷贝构造和赋值操作符,因为编译器不会为这两种成员赋值(不允许赋值const和引用)
6>. 不想要编译默认生成的函数,则可以声明为private,不用定义. 大量不需要的拷贝构造等函数,可定义一个基类,内部把拷贝构造声明为私有成员函数
7>. 声明虚析构函数,如果一个类会被继承.
	编译器会在派生类的析构函数内自动添加父类析构函数的调用.
	基类指针指向派生类对象时,如果析构函数不是虚函数,不会发生动态绑定,这是delete父类指针不会动态绑定到派生类对象的析构函数上.
	构造函数不能是虚函数因为在构造期间对象是不完整类型,比如在构造父类部分时编译器无法确定子类部分,也没有意义.
8>. 把可能抛出异常的代码放到析构函数之外,比如提供close函数, 避免资源泄露.
9>. 定义派生类对象时,构造基类部分而调用的基类构造函数内, 调用了一个虚函数, 此虚函数依然调用的是基类的版本而不是派生类的版本.
	在构造期间,虚函数不是虚函数.
10>.重载操作符时应该return *this 协议规定
11>.重载赋值操作符注意:
		1>.自己赋值给自己(可判断地址).
		2>.指针成员深拷贝浅拷贝.
12>.确保拷贝构造函数赋值对象内所有成员和基类的成分.
13>.智能指针.
	unique_ptr: unique_ptr独占对象内存.
		1>.转移对象内存时必须使用uni_ptr2 = std::move(uni_ptr) // 此时uni_ptr==nullptr
		2>.unique_ptr 在默认情况下和裸指针的大小是一样的,没有任何的额外消耗性能最优.
		3>.可以管理数组指针,另外两个不可以
		4>.使用在独占资源时,超出作用域时能自动释放内存,用于替代裸指针.
	shared_ptr：多个shared_ptr可以共享同一块内存,内部是利用引用计数来实现内存的自动管理,每复制一个shared_ptr引用计数+1
		1>.内存占用高; 引用计数的原因内存占用是裸指针的两倍
		2>.引用计数的增减必须是原子操作,性能低.
		3>.在复制shared_ptr时,如果此后都不会使用当前shared_ptr, 则可以使用移动std::move(shared_ptr)
		4>.使用在通常使用在共享权不明的场景,不确定何时释放.
	weak_ptr：weak_ptr只能从shared_ptr对象构建，且在必要时可以通过成员 lock 来返回一个指向当前内存的 shared_ptr 指针，如果当前内存已经被释放，那么将 lock() 返回 nullptr。
		1>.weak_ptr不影响指向对象的生命周期,完全由shared_ptr的引用计数掌控. 
		2>.当指向对象被shared_ptr释放后, weak_ptr.lock()将返回 nullptr, 如果未被释放weak_ptr.lock()返回一个shared_ptr
		3>.expired()成员判断指向对象是否已被释放
		4>.weak_ptr没有重载operator->和operator *操作符，因此不可直接通过weak_ptr使用对象
		5>.使用在避免与shared_ptr有相互引用的场景下,避免相互依赖无法释放资源.
14>.RAII,构造申请资源, 析构释放
15>.智能指针提供了get()返回原始指针
16>.new与delete  new[]与delete[]要成对出现
17>.不要在参数列表进行资源申请,应提前单独申请后传进去;避免多个申请,后一个失败时造成资源泄露.
18>. >.尽量返回智能指针而不是裸指针  >.尽量利用编译类型检查  >.返回智能指针可避免夸动态库申请释放问题,因为智能指针的删除器来自申请内存的动态库.
19>.略
20>.参数传递尽量使用引用(值传递是调用的拷贝构造函数生成实参的副本)
	传值时如果把派生类对象传给基类形参,则是调用基类拷贝构造函数,函数内部实际使用的是基类对象
21>.不要返回局部变量的引用. 尽量避免全局变量和静态变量. 可重入函数:只使用自己栈上的变量,不依赖于任何环境.
22>.尽量把成员函数声明成私有成员,控制访问权限比较安全.
23>.略
24>.隐式类型转换是在函数参数列表发生的, 2 * obj这种双目运算符需要定义成非成员函数.
25>.模板特化时`部分或全部`使用一个具体的类型. 
		1>.函数模板只允许全特化; 模板类可以全特化和偏特化
		2>.编译器匹配函数调用时的优先级为: 普通函数, 模板函数, 特化模板函数; 当没有普通函数匹配, 编译器开始平等挑选类型最匹配的基础函数模版, 被选中则继续查找是否有全特化版本, 如果有且类型匹配, 则选中全特化版本,没有则选中基础函数模板.
		3>.全特化模板函数优先级低的原因:特化违背了重载解析规则.
		4>.模板函数的特化是带template <...>, 重载是不带的,只变了参数类型或个数
		5>.模板函数与非模板函数可并存，共同作为同一重载体系.
		6>.重载可替代特化模板函数,编译器选择具体是哪个函数时重载函数的优先级更高
26>.略
27>.const_cast:去除或增加const属性. 去掉const属性后可被赋值,但对原const变量的访问,还是原来的值(编译器生成的指令码中直接使用数值)
	static_cast:强制类型转换. 如果也用父类对象的指针转子类指针,则子类指针调用子类独有成员时发生不明确行为.
	dynamic_cast:专用于派生类之间的转换. (运行期检查) 父类对象的指针转子类指针时返回空.
	reinterpret_cast:只是对二进制值做重新解读. 依赖具体的平台可移植性差. 例如指针转int
	尽量避免类型转换, 可提供一个专门的函数返回目标类型的对象
	优点:编译器进行类型安全检查
28>.略
29>.即使发生异常也不要资源泄露.
30>.类内定义的函数默认为内联函数(1).
	inline只是给编译器的建议,具体是否内联取决于编译器(2).
	带inline的虚函数, 编译器拒绝内联, 因为虚函数需要动态绑定, 与编译器替换代码有冲突.
	内联函数优点:没有函数压栈弹栈,效率高.
	内联函数缺点:
		1>.内联函数会引发代码膨胀,二进制可执行文件变大.
		2>.动态库中的inline函数被修改,所有调用者都需要重新编译; 非inline函数被修改只需要重新链接.
31>.降低编译依存度
		1>.声明放在头文件,定义放在源文件中.
		2>.尽量使用引用或者指针.
		3>.尽量以声明式代替定义式.
		4>.将实现定义于实现类,然后成员指针指impl向实现类.
32>.public继承是is-a的关系; public继承时基类内成员的访问控制权限不变.
33>.覆盖:子类中的函数返回值,函数名,参数列表都相同则会覆盖.
	隐藏:子类中存在与基类中同名的函数,则基类中所有同名函数被隐藏而无法在子类中调用;即使基类中函数的参数列表与子类中不同也全被隐藏.
		可使用using base::func1;显式不隐藏基类函数.
	重载:同一作用域下存在多个同名函数,其参数列表不同或参数类型不同. 返回值类型不参与函数重载,因为重载考虑返回值的话编译器需要理解上下文.
	多态:继承体系的多态是动态多态. 如果基类和子类有相同的函数(包括返回值,函数名,参数列表), 如果使用基类指针或引用指向子类对象,则再运行期根据指针指向的实际类型进行函数调用.	使用基类对象无法实现多态是因为赋值给基类对象时是调用的基类构造函数构造的;而指针和引用只是对子类对象内存的解释成基类指针或引用的类型
	多态和重载的区别:
		1>.多态发生在不同的作用域, 重载是在相同作用域.
		2>.多态的函数绑定发生在运行期, 重载的函数绑定发生在编译期.
		3>.多态具有相同的函数签名, 重载具有不同的函数签名.
34>.纯虚函数是接口继承, 虚函数是接口继承和缺省实现继承, 非虚函数是接口继承和强制实现继承.
35>.strategy策略设计模式.
36>.子类不应重新定义基类中的非虚函数,因为调用的是哪个函数取决于指针当初声明时的类型.(是静态绑定的)
37>.虚函数的调用是动态绑定的, 但虚函数的默认参数是静态绑定的. 
	如果子类虚函数中的默认参数和父类中不同,则在参数绑定时使用的是声明的指针类型中定义的默认参数;而不是实际指向对象的类中虚函数定义的默认参数.
38>.类间关系:关联, 聚合, 组合, 继承
	1>.继承:一个类(子类)继承另外一个类(基类)的功能,并增加它自己的新功能的能力; 实现单箭头指向基类
	2>.关联:一个类作为另一个类成员函数的参数; 用虚线表示
	3>.聚合:整体与部分的关系. 部分与整体的生存期无关,且可以改变部分所属的聚合对象; 比如指针成员. 空心菱形和实线表示
	4>.组合:也表示整体和部分的关系. 但组合中部分和整体有相同的生存期;比如普通成员变量,私有继承; 实心菱形和实线表示
39>.private继承也是组合的关系.
	public继承   : 基类成员的访问权在子类中保持不变.
	protected继承: 基类中的public和protected成员在子类中为protected权限; 基类中的private成员权限不变.
	private继承  : 基类中的所有成员在子类中都是private权限.
	public成员   : 可以在类外通过变量名,指针或引用进行访问.
	protected成员: 可以在子类中访问.
	private成员  : 只能在友元类/函数或此类内部访问
40>.菱形继承时应使用virtual虚继承(C++也允许不用虚继承,只是会有两份公共基类对象); 最下层的子类负责公共基类的初始化,无论距离公共基类多远, 避免在公共基类里放置数据成员可免除初始化公共基类的烦恼.
	虚继承可解决菱形继承中多份公共基类部分的问题, 但会在子类中添加一个指向公共虚基类部分的指针,用以解决基类部分重复的问题.
	虚继承的缺点:增加子类大小,执行速度变慢,实现公共基类部分初始化较复杂.
41>.编译期多态是通过模板具现化和函数重载解析发生于编译期.
42>.typename第一个作用是修饰模板参数, 第二个作用是免去编译器困惑,指定模板类型参数内的子类型.
	在修饰模板类型参数时class与typename作用完全相同,但typename可以显式指示A::abc是一个类中的子类型而不是静态成员变量,以避免编译器语法解析时的困惑.
		C++编译器有条规则解决这个歧义:如果解析器在模板中遇到嵌套依赖名字,则它假定那个名字不是一个类型,除非使用typename显式告诉编译器它是类型.
43>.继承模板类时,因为模板类可能存在特化版本,模板类特化可能不提供模板类一般性接口, 故编译器拒绝在模板基类中搜索调用的函数定义.
	调用继承自模板类中函数的解决方式有三种:
	1>.使用 'this->函数名(参数列表);'
	2>.使用 '模板类名::func(参数列表);' 的形式来指定.
	3>.调用模板基类中函数前,使用 'using 模板类名::函数名;' 显示告诉编译器存在此函数
44>.模板除可以接收类型参数外, 还可以接受普通函数那样的数值型参数
	1>.因数值型模板参数造成代码膨胀,通常可以用函数参数替代来避免.
	2>.因类型模板参数造成代码膨胀,通常可以让完全相同二进制表述的具现类型共享实现码.
45>.如果想让模板类之间支持隐式类型转换,可以定义模板类的'模板型的构造函数,拷贝构造,赋值操作符'来实现这种功能.
46>.编译器在模板实参推导(模板具现化)时从不考虑隐式类型转换的情况; 因为编译器不确定模板参数是否支持隐式类型转换. (隐式类型转换需要相应的构造函数)
	如果想让模板函数支持隐式类型转换,需要模板函数具现化(编译期生成具体类型的函数),而声明于模板类内部的模板函数会随着模板类的具现化而具现化,此时模板类提供了模板构造函数的话,就可以进行隐式类型转换了.
	在能够调用一个函数前,必须要知道那个函数的存在,知道那个函数的存在就需要具现化模板函数,具现化模板函数就需要知道模板参数的具体类型.
	1>.双目运算符的前后参数都想支持类型转换的话,那么重载运算符需要是操作对象类型的非成员函数.
	2>.在一个类内部,声明非成员函数的唯一办法是使它成为一个友元函数.
47>.STL迭代器分类:
	1>.input迭代器:只能前向移动,一次一步,且只能读一次指向的元素; 比如 istream_iterator
	2>.output迭代器:只能前向移动,一次一步,且只能写一次指向的元素; 比如 ostream_iterator
	3>.forword迭代器:只能前向移动,一次一步,但可以读或写多次; 比如slist单链表
	4>.bidirectional迭代器:可以前后移动,一次一步,也可以多次读写; 比如list双向链表, set, multiset, map, multimap
	5>.random access迭代器:可以算术移动任意距离,类似指针; 比如vector, deque, string
	编译期判断类型
48>.模板可用于编译期计算; 计算分为数值计算和类型计算.
	数值计算:
	类型计算:
49>.使用set_new_handler()设置一个堆内存分配失败的回调函数.
	利用局部变量超出作用域后被析构的特性,可以在对象专属的new操作符重载中设置自己的new_handler,new返回前恢复全局的new_handler.
	std::nothrow版的new只能保证new操作符不抛出异常,却不能保证new后对象的构造函数不抛出异常.
50>.略
51>.空类大小为1字节, 因为对象必须在内存中有一个地址的规范.
52>.内存对齐的原因:cpu访问内存时,把内存的操作放到控制总线,把要访问的内存地址放到地址总线,通过内存控制器,每次只能读取数据总线位宽大小的内存块,而内存块是根据cpu数据总线宽度划分而成的连续一次读或写的单元. 没有内存对齐的话,对内存的读写可能需要耗费多次操作.
	结构体对齐系数 = min((max(成员1类型长度,成员2类型长度...), setting_pack_len)
		注 : 当#pragma pack的n值大于等于各数据成员长度时，这个设置将不产生任何效果
	结构体对齐格式:
		#pragma pack(2)
		struct AA{...};
		#pragma pack()
53>.尽量零警告
54>.STL
55>.Boost

