第一章:简介
	1>.ipv4与ipv6协议之间只有两个区别:
		1>.sockaddr_in对应sockaddr_in6
		2>.AF_INET对应AF_INET6
	2>.OSI七层模型:其中底下4层处于内核中.
		1>.应用层:直接向用户提供接口实现各种服务.
			e.g., webrtc中的RTP/RTCP协议.
		2>.表示层:处理用户信息的表示问题,如数据格式处理和数据的编码和加密解密.
			e.g., webrtc中的DTLS协议.
		3>.会话层:组织和协调两个会话进程之间的通信,并对数据交换进行管理.
			e.g., webrtc中的ICE协议.
		4>.传输层:对上层屏蔽下层数据通信的细节,向用户提供可靠的端到端的差错或流量控制保证报文的正确传输,即向用户透明地传送报文.
			e.g., TCP/UDP/SCTP协议.
		5>.网络层:通过路由选择算法,为报文或分组通过通信子网选择最适当的路径.
			 作用:数据链路层的数据将在这一层被转换为数据包,然后通过路径选择,分段组合,顺序,进/出路由等控制,将数据包从一个网络设备传送到另一个网络设备.
		6>.数据链路层:通过各种控制协议,将有差错的物理信道变为无差错的,能可靠传输数据帧的数据链路.
			 作用:差错控制,流量控制方法,使有差错的物理线路变为无差错的数据链路,即提供可靠的通过物理介质传输数据的方法.
		7>.物理层:利用传输介质为数据链路层提供物理连接,实现比特流的透明传输.
			 作用:是实现相邻计算机节点之间比特流的透明传送,尽可能屏蔽掉具体传输介质和物理设备的差异.
	3>.TCP/IP四层模型:
		1>.应用层:对应OSI模型的顶上三层.
		2>.传输层:对应OSI模型的第四层.
		3>.网络层:对应OSI模型第五层.
		4>.数据链路层:对应OSI模型第六层和第七层.

第二章:传输层★★★
	1>. UDP协议:用户数据报协议,定义在RFC768. udp协议的特点:
		1>.无连接,没有建立连接与终止连接的开销,支持单播(点对点),组播,广播.
		2>.不可靠:不保证顺序,不保证只到达一次,丢包或校验发现错误直接丢弃而没有重传.
		3>.有数据包边界,不会粘包.
		4>.数据包分片发生在网络层(ip层).
		5>.传输效率高.
	2>. TCP协议:传输控制协议,最后的更新定义在RFC3390. TCP的特点:
		1>.有连接,只支持单播(点对点).
		2>.可靠:保证顺序,保证只到达一次,丢包重传.
		3>.没有数据边界,会发生粘包.
		4>.数据包分片发生在传输层(tcp协议处理分片).
		5>.传输效率没有udp高.
	3>. SCTP协议:流控制传输协议,定义在RFC2960. SCTP协议的特点:
		1>.两个sctp套接字之间是关联,而非连接.
		2>.提供可靠的,顺序到达,流量控制;也支持不完全可靠选项.
		3>.有数据包边界,不会粘包.
		4>.支持多流,一个流阻塞不影响其他流的传输.
		5>.支持多宿主,使用多个ip增强面对网络故障的健壮性.
	4>. TCP建立连接的三次握手:
		1>.首先客户端发送SYN并带上初始序列号j.
		2>.服务端为SYN请求应答ACK并带上客户端的初始序列号+1的值,以及服务端发送自己的SYN请求并带上服务端的初始序列号k.
		3>.客户端为服务器的SYN请求应答ACK并带上服务端的初始序列号+1的值.
	5>. 在建立TCP连接时,可通过MSS选项告知对端发送方的最大分片长度,不同方向上的MSS值可以不同;通过设置套接字选项修改.
	6>. TCP连接终止的四次挥手:
		1>.A端向B端发送FIN并携带序列号M.
		2>.B端为FIN应答ACK并携带序列号M+1.
		3>.B端向A端发送FIN并携带序列号N.
		4>.A端为FIN应答ACK并携带序列号N+1.
	7>. SYN和FIN有序列号是因为需要重传时屏蔽掉过期的ACK;ACK没有序列号因为它自己不用被确认.
	8>. TCP状态转换图,共11个状态由于不好用文本画出状态迁移,改为文字表述:
		1>.服务端状态转变:
			1>.创建socket后初始状态为CLOSED.
			2>.调用listen函数后状态变为LISTEN.
			3>.在收到SYN请求并发SYN和ACK后状态变为SYN_RECV.
			4>.在收到ACK后状态变为ESTABLISHED.
		2>.客户端状态迁移:
			1>.创建socket后初始状态为CLOSED.
			2>.调用connect主动连接后状态变为SYN_SEND.
			3>.在收到SYN和ACK并发送ACK状态变为ESTABLISHED.
		3>.同时打开状态迁移:
			1>.创建socket后初始状态为CLOSED.
			2>.发送SYN后状态变为SYN_SEND.
			3>.此时接收到了SYN,并应答SYN,ACK后状态变为SYN_RECV.
			4>.任意一方在收到ACK确认后状态变为ESTABLISHED.
		4>.主动关闭状态迁移:
			1>.发送FIN后状态变为FIN_WAIT1.
			2>.接收到ACK后状态变为FIN_WAIT2.
			3>.接收FIN并应答ACK后状态变为TIME_WAIT.
			4>.经过2MSL之后状态变为CLOSED.
		5>.被动关闭状态迁移:
			1>.收到FIN,应答ACK后状态变为CLOSE_WAIT.
			2>.发送FIN后状态变为LAST_ACK.
			3>.收到ACK后状态变为CLOSED.
		6>.同时关闭状态迁移:
			1>.双方都发FIN后状态变为FIN_WAIT1.
			2>.双方收到对端的FIN后状态变为CLOSING.
			3>.任一方谁接收到ACK,谁的状态变为TIME_WAIT.
			4>.经过2MSL之后状态变为CLOSED.
		执行主动关闭方会最终会进入TIME_WAIT状态,发生同时关闭时,双方均会进入TIME_WAIT状态.
	9>. 通常TCP在处理请求并产生应答的时间少于200ms时会合并ACK与应答数据一并发送.
	10>.TIME_WAIT状态持续1分钟到4分钟之间.存在TIME_WAIT状态的原因:
		1>.可靠的实现全双工连接的终止.当主动关闭端的4次挥手的最后一个ACK包丢失,必须能够接收对端重发的FIN包,直到FIN包对应的ACK应答送达对端,否则对端无法正确关闭.
		2>.允许由路由故障引起的漫游的重复分节在网络中消失,而不会被新打开的连接接收.
	11>.SCTP也是面向连接的,因此也有4次握手:
		1>.客户端通过connect发送一个INIT消息,并带上自己的IP地址清单,初始序列号,起始标记,请求的流的个数,支持的对端流的个数.
		2>.服务器应答INIT ACK消息,并带上服务端的IP地址清单,初始序列号,起始标记,请求的流的个数,支持的对端流的个数,和状态cookie.
		3>.客户端回射服务端的状态cookie,可能在同一分组中还捆绑了用户数据.
		4>.服务端应答COOKIE ACK消息以确认回射cookie是正确的,支持SCTP关联建立成功.
	12>.SCTP握手中的INIT ACK消息中的cookie包含设置本SCTP关联所需的所有状态,这样服务端SCTP栈就不需要保存客户的有关信息,防止DDOS攻击.
	13>.SCTP的3次挥手:
		1>.一端发送SHUTDOWN消息
		2>.另一端收到请求后必须停止发送数据,并发送SHUTDOWN ACK消息.
		3>.主动发起方则发送SHUTDOWN COMPLETE.
	14>.SCTP没有也不需要TIME_WAIT状态,因为每个SCTP包都有验证标记,新连接可判断是否是旧连接的数据包.
	15>.0~1023端口为众所周知的端口,有IANA分配控制,定义在RFC1700中.
	16>.UDP分片发生在网络层(IP层),以满足数据链路层最大MTU的要求并将数据送入数据链路层.
		TCP分片发生在传输层(TCP协议),因为由IP层负责分片的话,如果丢失一片需要重传整个包,由TCP进行分片则只需重传丢失的分片就行了.
	17>.当IP首部'不分片'位(DF位)被设置,当路由器或本机下层协议接收到一个超过其MTU值的数据报时,将产生一个ICMP'目的地址不可达,需要分片但DF位已设置'的错误信息.
	18>.TCP在握手时协商一个MSS选项,告知对端其重组缓冲区的大小以避免分片,因为分片的话其中一个片丢包需要重传整个包的所有片.
		MSS常设置为MTU减去ip包头和TCP包头的长度.
	19>.TCP send调用成功仅代表数据写入内核发送缓冲区,然后内核分节成MSS大小的数据包并加上TCP首部传递给网络层发送给对端,只有收到对端的ack确认才会从内核缓冲区中清除.
		当内核缓冲区满时send调用将阻塞(套接字默认为阻塞模式)
	20>.UDP的数据包不需要接收确认,因此数据链路层发送数据之后,内核缓冲区中的数据包就会被清理.如果内核缓冲区没有足够空间,通常返回ENOBUFS错误.
	21>.SCTP内核发送缓冲区与TCP一样,需要等待确认再清除内核发送缓冲区中的数据.
	22>.TCP路径MTU发现:
		1>.套接字连接成功后,通过调用getsockopt指定TCP_MAXSEG来获取对端通告的MSS大小.
		2>.对套接字调用setsockopt指定IP_MTU_DISCOVER设置打开IP首部的DF位.
		3>.以对端通告的MSS大小和本地MSS大小的最小值做为数据报长度发送探测数据包.
		4>.如果对端应答成功,则当前MSS值+TCP包头长度为路径MTU.
			如果套接字发生异常(ICMP数据包过长但DF位已设置的错误),则减小数据报长度继续发送探测请求,直到对端应答成功.
	23>.UDP路径MTU发现:与TCP路径MTU探测类似,但UDP须connect绑定对端地址,才能接到ICMP错误通知;探测完成再次connect地址族设置为AF_UNSPEC以清空.

	附加说明ICMP协议:属于网络层(ip层)协议,用于在主机与路由之间传递控制信息,包括报告错误,交换受限控制和状态信息;e.g., 无法路由消息时报告不可达.
第三章:套接字编程
	1>. 套接字地址结构共有5种:IPv4(sockaddr_in), IPv6(sockaddr_in6), Unix域(sockaddr_un), 数据链路(sockaddr_dl), 共享存储(sockaddr_storage).
	2>. 小端字节序:内存低地址存储低位字节,高地址存储高位字节.
		大端字节序:内存低地址存储高位字节,高地址存储低位字节.
		主机字节序:系统使用的字节序;其不是有操作系统决定的,而是由cpu指令集架构决定的.Intel和ARM使用小端字节序.
		网络字节序:网络协议使用的字节序;为大端字节序.
		htons/htonl用于短整型和整型从主机字节序转到网络字节序.
		ntohs/ntohl用于短整型和整型从网络字节序转到主机字节序.
	3>. inet_aton/inet_ntoa函数用于IPv4的字符串IP地址 与 网络字节序32位整型IP值 之间的转换.(不建议用)
	4>. inet_pton/inet_ntop函数用于IPv4/IPv6的字符串地址 与 网络字节序IP数值的地址结构 之间的转换.p代表'表达字符串', n代表'数值'.

第四章:TCP套接字编程
	1>. socket函数用于创建套接字,参数为:地址族AF_INET/AF_INET6,类型SOCK_STREAM/SOCK_DGRAM/SOCK_SEQPACKET/SOCK_RAW等,协议TCP/UDP/SCTP等.
	2>. bind函数用于把本地地址协议绑定到套接字.客户端通常不绑定本地地址,内核将根据到达服务端的外出网卡接口来选择本地IP地址.
	3>. connect函数用于TCP建立连接阻塞到连接成功或连接超时.客户端在调用connect之前不必调用bind绑定本地地址,内核会确定本地地址及临时端口号.
		如果套接字设置为非阻塞模式connect会立即返回-1,然后通过IO多路复用等待socket事件.
		UDP套接字调用connect函数相当于绑定对端地址,然后才能使用send/recv不带对端地址参数的函数.
		connect出错的3种情况:
			1>.SYN请求未得到响应超时错误.
			2>.服务端没有打开指定端口然后应答了RST,连接被拒绝的错误.
			3>.中间路由返回ICMP的目的地址不可达错误.
		产生RST包的3个条件:
			1>.指定端口未监听.
			2>.TCP想取消一个已有连接.
			3>.收到不存的连接上的数据时应答RST.
	4>. listen函数指示套接字开始接受连接请求,把一个未连接的主动套接字转换成被动套接字.
		内核为监听套接字维护两个队列:
			未完成连接队列:接收SYN后在此队列添加一项.
			已完成连接队列:三次握手后从未完成连接队列移到此处后accept才返回.
	5>. accept函数从已完成连接队列头取走一个已连接的套接字;
		如果已完成连接队列为空则accept函数将一直阻塞到有套接字建立连接为止,其中输出参数为返回的套接字的对端地址信息.
	6>. close函数用于关闭套接字.close之后将不能使用此套接字进行收发数据,但将尝试发送在内核缓冲区中的数据,发送完毕后才终止TCP连接.
		当创建子进程复制了套接字描述符的副本,在父进程close套接字而子进程并没有close的话,则终止TCP连接会延迟到子进程也close套接字(套接字描述符的引用计数为0).
	7>. shutdown函数用于在TCP连接上发送一个FIN,来关闭本端的发送,此时还可以操作套接字接收数据.
	8>. getsockname/getpeername函数分别用于获取套接字上本地地址或对端地址信息.
	9>. 各接口TCP状态转换:
			1>.socket函数创建一个初始为CLOSED状态的套接字.
			2>.bind无状态变化.
			3>.connect函数从CLOSED状态转变成ESTABLISHED状态.
			4>.listen函数从CLOSED状态转变成LISTEN状态.
			5>.accept函数把复制的socket从LISTEN状态转变成ESTABLISHED状态.
			6>.close函数从ESTABLISHED状态转变为TIME_WAIT状态,经过2MSL时间后变为CLOSED状态.
				1>.套接字描述符引用计数减1,仅在引用计数为0时才关闭套接字.
				2>.close终止读写两个方向的数据发送.
			7>.shutdown函数从ESTABLISHED状态转变为FIN_WAIT1状态.
				SHUT_RD:关闭读半部分,接收缓冲区中现有数据将关闭,且不能调用任何读函数;接收到来自对端的任何数据都被确认并丢弃.
				SHUT_WR:关闭写半部分,属于半关闭本端会发送FIN.当前发送缓冲区中的数据会被发送,然后发送FIN关闭写端而不判断套接字引用计数是否为0.
				SHUT_RDWR:相当于各调用一次SHUT_RD和SHUT_WR参数的shutdown函数.
第五章:TCP客户端服务器★★★
	1>. accept函数返回前客户端中止连接,有些操作系统实现为accept返回ECONNABORTED错误,Linux操作系统正常返回套接字,但当读此套接字时返回ECONNRESET错误.
		TCP连接建立成功还未accept取走已连接套接字时,server收到RST后会将所有状态清理,直接断掉连接但是没有将申请的资源回收,这个过程是在close中完成的.
	2>. 当服务端进程异常中止,内核将关闭所有文件描述符(包括套接字).这将导致向客户端发送FIN,客户端套接字将处于半关闭状态CLOSE_WAIT.当客户端再次调用read函数返回EOF时才能发现对端已关闭.
		使用IO多路复用可获知收到对端发送了FIN的可读事件.
	3>. 对端发送FIN本端已应答ACK的半关闭状态套接字,此时通过此(半关闭)套接字可继续向对端发送数据.
		1>.对端close套接字导致本端套接字接收到FIN并处于半关闭状态,此时对端还能接收数据.
		2>.但如果是对端进程异常退出导致的本端收到FIN处于半关闭,则本端再发送数据给对端就会收到对端主机应答的RST了.
		3>.已经收到RST的套接字再次写入发送时,将触发SIGPIPE信号导致进程终止,必须捕获此信号避免进程退出.
		写一个已接收FIN的套接字没有问题,但写入一个已经接收RST的套接字则是一个错误.
	4>. 当建立连接后对端主机崩溃,此时发送数据会一直重传直到超时或返回目的地址不可达错误.
		当建立连接后对端主机崩溃后重启,此时发送数据给对端则会收到RST应答.
		当建立连接后对端主机关机/对端进程异常终止,则init进程给所有进程发送退出信号,进程退出将关闭所有文件描述符从而触发发送FIN给对端.

第六章:IO多路复用★★★
	1>. 同步:完成之前不返回.
		异步:没完成也立即返回.
		阻塞:不能去干别的.
		非阻塞:可以去干点别的.
		同步和异步关注的是消息通知的机制,主动等待消息返回还是被动接受消息.
		阻塞和非阻塞关注的是程序在等待调用结果(消息,返回值)时的状态,阻塞等待还是立刻返回.
	2>. 5种IO模型:
		1>.阻塞IO,套接字默认的模式.
			特点:能够及时返回数据无延迟,但需要等待.
		2>.非阻塞IO,通过fcntl或ioctl设置非阻塞模式.
			特点:不用等待可以执行其他任务,但需要轮训IO状态增加了延迟和降低了吞吐量.
		3>.信号驱动式IO(SIGIO).
			特点:对多个socket支持不太好,产生信号后不知道对应哪个socket.
		4>.异步IO(POSIX的aio_系列函数).
			posix异步与信号驱动式IO非常类似,区别在于:信号驱动式IO是由内核通知何时可以开始一个IO操作,而posix异步IO则是内核通知我们io操作何时完成.
		5>.IO多路复用,select/poll/epoll方式.
			特点:能够同时处理多个连接且系统开销小,但并发量小的话比阻塞IO延迟高且无法保证请求与处理间的先后顺序.
	3>. select函数用于告知内核对于哪些描述符的读/写/异常事件感兴趣及最长等待时间.
		FD_ZERO/FD_SET/FD_CLR/FD_ISSET宏用于操作描述符集合.
		描述符可读事件:
			1>.接收缓冲区中字节数大于等于接收缓冲区低水位标记的值(低水位标记值默认为1,可修改).
			2>.收到FIN的半关闭连接,读操作将返回0(EOF).
			3>.监听套接字上已完成连接队列中个数部位0.
			4>.套接字有待处理错误(当套接字上有错误发送将标记为即可度又可写).
		描述符可写事件:
			1>.发送缓冲区可用空间字节数大于等于缓冲区低水位标记的值(发送缓冲区低水位标记值默认为2048,可修改).
			2>.已经发送过FIN关闭了写半部分.
			3>.非阻塞套接字连接成功或失败.
			4>.套接字有待处理错误(当套接字上有错误发送将标记为即可度又可写).
		描述符异常事件:
			1>.收到外带数据/紧急数据.
	4>. pselect函数与select函数的区别:
		1>.超时参数的类型不同.
		1>.增加一个屏蔽信号集参数,以原子的方式安装一个信号屏蔽字,在返回的时候恢复信号屏蔽字.
	5>. poll函数类似于select函数但只使用一个pollfd数组,而select使用三个类似结构的参数.
		读写关注事件需要设置,而关注的异常事件无需设置当事件发生时也会置位.

第七章:套接字选项★★★
	1>. 函数获取或设置套接字选项:
		getsockopt/setsockopt函数
		fcntl函数
		ioctl函数
	2>. 套接字选项分为SOL_SOCKET,IPPROTO_TCP,IPPROTO_IP,IPPROTO_IPV6,IPPROTO_SCTP,常用的选项有:
		SO_BROADCAST选项: 允许发送广播数据(udp).
		SO_DEBUG选项: 开启调试追踪,tcp发送和接收的分组将保存在内核中的某个环形缓冲区,使用trpt程序进行检查分析.
		SO_LINGER选项: 关闭套接字时如何对待发送缓冲区中的数据(有数据发送是否延迟关闭)及以哪种方式关闭套接字(四次挥手/RST).
			1>.close立即返回,如果可能将继续传输发送缓冲区的数据,这种属于socket的默认行为.
			2>.丢弃缓冲区数据并发送RST而非4次挥手,避免TIME_WAIT状态,但可能会导致旧连接上的数据包不正确的传递到新的分组上.
			3>.设置一个关闭超时时间,直到缓冲区数据全部发送并被对端ACK确认或超过最大等待时间后丢弃缓冲区数据close函数才返回.
		SO_RCVBUF/SO_SNDBUF选项: 调整接收发送缓冲区大小.
		SO_RCVLOWAT/SO_SNDLOWAT选项: 接受发送缓冲区低水位标记(影响IO多路复用读写事件的触发条件).
		SO_RCVTIMEO/SO_SNDTIMEO选项: 接收发送接口的超时时间,对接收系函数及发送系函数产生影响.
		SO_REUSEADDR选项: 允许重用本地地址(对于TIME_WAIT状态的套接字占用资源问题).
		SO_REUSEPORT选项: 允许重用本地端口,tcp会均匀分配连接,udp则把数据包均匀随机落点.
		SO_KEEPALIVE选项:测试连接是否存活,比较鸡肋时间2小时一次.只能通过修改内核的方式改短时间且影响所有套接字.
		TCP_MAXSEG选项: 获取或设置TCP的MSS值,默认值时SYN中协商的,通常只能设置为比协商值小的值.
		TCP_NODELAY选项: 设置禁止TCP的Nagle算法.
		TCP_CORK选项: 设置拼接多次send放入缓冲区中的数据以达到MTU的大小或内核等到一定时间(没有触发前边的条件)再发送一次数据包.
		TCP_QUICKACK选项: 设置取消延迟确认.
		IP_MTU_DISCOVER选项:设置IP包头的DF位.
		IP_RECVIF选项:获取网卡索引.
		IP_RECVDSTADDR选项:获取接收数据报的目的地址.
		IP_HDRINCL选项: 对原始套接字设置自己的IP首部.
		IP_TOS选项: 设置tcp/udp/sctp套接字中ip首部的服务类型字段,以便获得ISP网络服务供应商的特别照顾(e.g. 低延迟,高吞吐).
		IPV6_PATHMTU选项: 用于获取路径MTU发现功能确定的当前MTU值.
		IPV6_IPV6ONLY选项: 用于禁用掉双栈主机上IPv6监听套接字对IPv4客户端请求的支持(默认支持,内核会做映射).
		有些套接字选项是监听套接字继承来的,须先给监听套接字设置这些选项:SO_DEBUG,SO_DONTROUTE,SO_KEEPLIVE,SO_LINGER,SO_OOBLINE,SO_RCVBUF,SO_SNDBUF,SO_RCVLOWAT,SO_SNDLOWAT,TCP_MAXSEG,TCP_NODELAY.
	3>. fcntl函数用于控制文件描述符或获取套接字属性状态.
		O_NONBLOCK标志设置套接字为非阻塞IO.
		O_ASYNC标志用于设置信号驱动式IO.
		F_SETOWN标志设置接收信号的进程.
	4>. Nagle算法:任意时刻最多只能有一个未被确认的小段. "小段"指小于MSS尺寸的数据块, "未被确认"指一个数据块发送出去后没有收到对方发送的ACK确认该数据已收到.
		Nagle算法就是为了尽可能发送大块数据,避免网络中充斥着许多小数据块.
		Nagle算法只允许一个未被ACK的包存在于网络而并不管包的大小,如果对端ACK回复很快的话,Nagle事实上不会拼接太多的数据包,虽然避免了网络拥塞但网络总体的利用率依然很低.
	5>. CORK算法与Nagle算法非常类似,但是它们的着眼点不一样.
			Nagle算法主要避免网络因为太多的小包(协议头的比例非常之大)而拥塞
			而CORK算法则是为了提高网络的利用率,使得总体上协议头占用的比例尽可能的小.

第八章:UDP套接字编程★★★
	1>. 若数据接收进程未运行,发送到此进程的数据将应答icmp端口不可达包.
		UDP套接字sendto调用是立即返回的,只有该UDP套接字调用connect绑定过对端地址后,这个端口不可达的异步错误才返回给进程.
	2>. 对未连接的UDP套接字调用connect函数,内核只是检查是否存在立即可知的错误(上边的ICMP端口不可达无法返回),记录对端IP和端口号然后返回.
		对UDP套接字调用connect函数,套接字将产生3个变化:
		1>.不能使用sendto函数,或使用sendto时不能指定对端地址参数了.
		2>.不必使用recvfrom了,不是来自connect绑定的对端地址的数据内核不会投递到此套接字,限制了只能和一个对端交换数据报.
		3>.已连接的UDP套接字引发的异步错误返回给所在进程(未连接的UDP套接字不接收任何异步错误).
	3>. TCP套接字和已连接的UDP套接字可以使用sendto,但不能指定目的地址参数,否则将返回错误.
	4>. 对UDP套接字多次调用connect函数:
		1>.指定新的对端地址信息.
		2>.地址结构参数中的地址族设置为AF_UNSPEC时断开套接字,使之成为未连接UDP套接字(未调用connect函数的udp套接字的默认状态).
	5>. 当在未连接UDP套接字上使用sendto发送数据时,内核先连接套接字然后发送数据,发送完之后再断开套接字连接.
		如果应用层知道需要持续发送数据到同一对端时,显式连接套接字效率更高,节省了sendto调用每次都需要先连接之后断开的开销.
	6>. 对UDP套接字调用connect可用于确定到某个目的地址的本地地址和临时端口.本地地址是内核为目的地址搜索路由表得到的主IP地址.

第九章/第十章:SCTP 略

第十一章:名字与地址转换
	1>. DNS:域名系统用于主机名字与IP地址间的映射.主机名既可以是简单字符串名字(gouzi),也可以是一个全限定域名(baidu.com).
		应用程序通过调用解析器的函数库中的函数访问DNS域名服务器.常见的解析器函数有gethostbyname/gethostbyaddr等.
		解析器通过读取系统相关配置确定域名服务器的位置.
	2>. /etc/hosts文件提供获取主机名和地址信息.
	3>. gethostbyname/gethostbyaddr函数分别用于获取主机名或ip地址,仅支持IPv4.
	4>. getservbyname/getservbyport函数分别用于获取服务对应端口或服务名(ftp,ssl,http).
	5>. getaddrinfo函数用于获取主机名或地址信息,既支持IPv4又支持IPv6,在输出参数的成员中指明是IPv4还是IPv6.
		gai_strerror函数获取getaddrinfo返回的错误号对应信息的字符串.
		freeaddinfo函数释放getaddrinfo返回的addrinfo结构的内存.
	6>. getnameinfo函数用于以地址为参数获取主机名和服务名的字符串.

第十二章:IPv4与IPv6的互操作性
	1>. 双协议栈技术,隧道技术,NAT64协议转换技术.
	2>. 双栈主机的IPv6服务既能处理IPv4又能处理IPv6,通过使用IPv4映射IPv6地址来为不同网络下的客户端提供服务.
	3>. 双栈主机处理IPv4和IPv6数据包的几种情况:
		1>.IPv4客户端能和IPv4或IPv6服务端通信,和IPv6服务端通信时内核在网络层将IPv4映射成IPv6投递到传输层.
		2>.IPv6客户端只能和IPv6服务器通信,内核不做IPv6到IPv4的映射(自己硬要修改内核也可以支持,只是IPv6个数比IPv4多的多).
	4>. 双栈主机在处理监听套接字时的原则:
		1>.IPv4监听套接字只能处理IPv4客户端的请求.
		2>.绑定了通配地址的IPv6监听套接字且未设置IPV6_IPV6ONLY选项,此套接字既可接收来自IPv4客户端的连接也可接收来自IPv6客户端的连接.
			对来自IPv4客户端的连接而言,其服务端的本地地址将是与某个本地IPv4地址对应的IPv4映射的IPv6地址.
		3>.如果服务器有一个IPv6监听套接字,且绑定的地址是除IPv4映射的IPv6地址之外的某个非通配IPv6地址,或者绑定的是通配地址但设置了IPV6_IPV6ONLY选项,则该套接字只接受来自IPv6客户端的请求.
	5>. IPv4与IPv6的客户端服务器连通性总结(以TCP为例,UDP一样):
		1>.双栈主机上的IPv6监听套接字,可以和IPv4/IPv6协议的单/双栈主机四种客户端通信;因为来自单栈主机的IPv4数据包在服务侧会映射成IPv6.
		2>.双栈主机上的IPv4客户端在客户侧不能映射(升级)成IPv6数据包发出去.
		3>.双栈主机上的IPv6客户端在客户侧可以映射(降级)成IPv4数据包发出去.
		4>.单栈主机上IP协议无法映射;在本端发出去的或收到的是IPv4的不会映射成IPv6,是IPv6的也不会映射成IPv4.
	6>. 有一些宏用于判断是否是映射地址(IPv4映射成IPv6的或者IPv6的映射成IPv4的),定义在<netinet/in.h>中.
	7>. IPv4向IPv6升级:
		1>.服务端部署在双栈主机上并改为IPv6套接字.
		2>.只支持IPv4相关的函数升级为协议无关函数.gethostbyaddr/gethostbyname替换成getaddrinfo/getnameinfo,以及借助编译预处理宏封装协议无关函数简化代码.

第十三章:守护进程
	1>. 守护进程的启动方式:
		1>.系统初始化脚本启动;在系统启动阶段,按照如/etc目录或/etc/rc开头的目录中的某些脚本启动,这些守护进程一开始就有超级用户权限.如inetd,cron,Web服务器.
		2>.由inetd超级服务器启动. inetd监听网络请求(FTP，Telnet..),每当一个请求到达时,启动相应实际服务器.
		3>.cron守护进程启动;cron按照规则定期执行一些程序.
		4>.at命令. at命令指定某个时刻启动程序,这些程序由cron启动.
		5>.用户终端启动,需要守护进程亲自脱离与控制终端的关联.
	2>. 守护进程无控制终端,无法输出消息,可使用syslogd系统守护进程记录消息.
		syslogd系统守护进程读取/etc/syslog.conf配置(SIGHUP信号重读配置文件),并提供3种日志接收方式:
		1>.打开Unix域套接字并绑定到/var/run/log或/var/log,接收系统内其他进程的日志.
		2>.创建UDP套接字绑定到514端口,接收网络日志.
		3>.打开/dev/klog,从该设备文件读取内核日志.
	3>. 守护进程可以调用syslog函数通过syslogd系统守护进程记录日志,该函数封装了使用Unix域套接字的方式写日志.
	4>. linux中提供了daemon函数,用于将一个普通进程转变为守护进程,内部执行了如下步骤:
		1>.调用fork并终止父进程,使子进程在后台运行,也保证了子进程不是进程组的组长才可以创建新的会话.
		2>.调用setsid创建新会话,使子进程成为新会话头进程和新进程组的组长进程,从而不再有控制终端.
		3>.忽略SIGHUP并再次调用fork并再次终止父进程(留下孙子进程继续运行).
			忽略SIGHUP信号是因为会话头进程终止时会话中所有进程都会收到SIGHUP信号,而父进程终止是我们主动退出父进程产生的所以无需处理.
			调用fork目的是使留下的孙子进程不是会话头进程,如果是会话头进程的话后续打开终端设备会获得控制终端;再次fork可以避免这种情况.
		4>.改变工作目录,因为守护进程可能在文件系统任何地方被启动,避免无法卸载该文件系统.
		5>.关闭守护进程继承来的所有打开的描述符,避免误读写.
		6>.将stdin,stdout,stderr重定向到/dev/null.保证这些常用描述符是打开的，针对他们的系统调用read返回EOF，write则由内核丢弃所有数据，因此守护进程不会因为调用这些程序而失败.
	5>. inetd系统守护进程接管普通守护进程的大部分启动细节,每收到一个外部请求然后启动对应的子进程处理请求. e.g., ftp,telnet,ssh等,不适用于服务密集型服务器.

第十四章:高级IO函数
	1>. 套接字IO操作设置超时的三种方式:alarm闹钟,IO多路复用,SO_RECVTIMEO/SO_SNDTIMEO选项.
		1>.alarm闹钟
		2>.IO多路复用
		3>.SO_RECVTIMEO/SO_SNDTIMEO选项
	2>. recv和send函数类似标准IO的read/write函数,但多一个flags参数用于控制读写操作.flags参数有:
		MSG_DONTROUTE:跳过路由表查找,目标主机在直联本地网络上.
		MSG_DONTWAIT:把单个操作临时指定为非阻塞,类似于打开套接字描述符的非阻塞标志.
		MSG_OOB:指定发送或接收的是TCP紧急数据(外带数据).
		MSG_PEEK:查看可读取的数据,而数据依然后在内核接收缓冲区中.
		MSG_WAITALL:指定内核在读取指定字节数之前不要返回,除非被信号中断/连接被终止/套接字发生一个错误这三种情况发生.
	3>. readv和writev函数用于连续写入或接收多个缓冲区,避免多次系统调用.
	4>. recvmsg和sendmsg函数是最通用的IO函数;所有send系write系函数都可以替换成sendmsg, 所有recv/read系函数都可以替换成recvmsg.
		参数msghdr结构体说明:
			msg_name/msg_namelen类似未连接UDP套接字的recvfrom/sendto中的对端地址参数.
			msg_iov/msg_iovlen类似readv/writev函数的缓冲区数组参数.
			msg_control/msg_controllen参数指定可选的辅助数据位置和大小.
			msg_flags参数:recvmsg调用时把函数参数flags复制到msg_flags成员,使用msg_flags驱动接收处理过程并根据结果更新msg_flags成员;sendmsg调用直接使用flags参数而忽略msg_flags结构体成员.
		flags/msg_flags参数说明:
			MSG_BCAST:发送或接收UDP广播.
			MSG_TRUNC:接收的数据被截断.
			MSG_CTRUNC:接收的辅助数据被截断.
			MSG_EOR:返回数据结束一个逻辑记录.
	5>. 辅助数据也被成为控制信息;通过recvmsg/sendmsg函数指定msg_control及长度参数应用辅助数据(对单个数据报有效);也可使用setsockopt设置辅助数据应用于该套接字上的所有分组.
		辅助数据由一个或多个辅助数据类型的cmsghdr对象构成.
		IP_RECVDSTADDR:接收UDP对端地址.
		IP_RECVIF:接收接口索引.
		IPV6_DSTOPTS:指定或接收目的地选项.
		IPV6_NEXTHOP:指定下一跳地址.
		IPV6_PKTINFO:指定或接收分组信息.
		IPV6_RTHDR:指定或接收路由首部.
		SCM_RIGHTS:发送或接收描述符.
		SCM_CREDS:发送或接收用户凭证.
	6>. 获取套接字接收缓冲区中数据长度的三种方式:
		1>.非阻塞IO.???
		2>.对recv函数指定MSG_PEEK标志.
		3>.对ioctl函数指定FIONREAD参数获取长度.
	7>. kqueue是FreeBSD平台的IO多路复用接口,类似于epoll解决了select/poll诸多问题,kqueue还提供了对文件修改通知,进程追踪和信号处理等.
		kqueue()函数用于创建一个kqueue描述符.
		kevent(...)函数既用于注册关注的事件(超时参数置为0),又用于等待关注事件的发生.
		EV_SET函数用于设置初始化一个kevent对象, e.g., 设置关注的描述符及事件.

第十五章:Unix域协议
	1>. Unix域协议并不是一个实际的协议族而是一种主机内的通信方法,所用API就是网络通信套接字的API.
		Unix域套接字的3个优点:
			1>.Unix域套接字比TCP套接字快一倍(参见APUE).
			2>.可以在主机内的任意进程间传递描述符.
			3>.可以传递客户凭证.
	2>. Unix域套接字使用sockaddr_un地址结构.
	3>. 创建使用Unix套接字与网络套接字基本一致:
		1>.socket创建套接字.
		2>.bind绑定一个本地路径名(如果已存在此路径名或关闭Unix域套接字调用unlink删除此路径名).
		3>.listen监听连接请求.
		4>.connect连接到一个已绑定本地路径的Unix域套接字.
		5>.accept返回已连接Unix域套接字.
		6>.close关闭Unix域套接字.
		7>.unlink删除本地文件系统中的路径名.
	4>. socketpair函数用于创建两个已经连接起来的Unix域套接字.
	5>. 对Unix域套接字调用套接字IO函数时存在一些差异:
		1>.域套接字关联的路径名应是绝对路径名,避免依赖当前工作目录.
		2>.connect调用中指定的路径名必须是一个当前已打开Unix域套接字上的路径名,且套接字类型(e.g.,字节流/数据包)也要一致.
		3>.connect连接Unix域套接字的权限测试等同于open此路径名.
		4>.connect调用如果监听套接字队列已满不会重试直接返回错误,而TCP会重试几次.
		5>.字节流的Unix域套接字类似TCP是可靠的无消息边界的; 数据包Unix域套接字类似UDP是不可靠的提供消息边界的.
		6>.在未绑定的Unix域套接字上发送数据不会绑定临时路径名,此时接收端无法发回应答数据,connect调用也不会给本套接字绑定临时路径名.
	6>. 使用Unix域套接字在进程间传递描述符步骤:
		1>.创建Unix域套接字.
		2>.打开一个文件描述符用于发送.
		3>.将描述符放入msghdr结构的msg_control成员作为辅助数据调用sendmsg函数发送.
		4>.接收进程调用recvmsg接收描述符,传递描述符并不是传递描述符号(i.e.,在接收进程创建一个新的描述符并指向发送进程中的描述符在内核中相同的文件表项).

第十六章:非阻塞IO
	1>. 套接字默认是阻塞的,阻塞的套接字调用分为4类:
		1>.输入操作(e.g. read,readv,recv,recvfrom,recvmsg).
		2>.输出操作(e.g. write,writev,send,sento,sendmsg).
		3>.接受外来连接(e.g. accept函数).
		4>.发起对外连接(e.g. TCP的connect函数).
	2>. 通过fcntl函数对套接字设置O_NONBLOCK标志以开启非阻塞IO模式.
	3>. 对非阻塞套接字调用connect之后, 须使用select等待连接建立成功.
		然而如果在调用select之前连接已建立成功且已收到对端数据,这时select套接字是可读又可写的,和连接建立失败的情况一样;可通过一下3种方式判断:
			1>.getpeername返回错误则是连接失败.
			2>.以0字节长度参数调用read返回错误则连接失败.
			3>.再调用一次connect如果返回EISCONN错误则已经连接成功,否则是连接失败.
	4>. FreeBSD中对于默认的阻塞套接字调用connect在TCP三次握手完成前被中断,将返回EINTR错误;此时继续调用connect将返回EADDRINUSE地址被占用错误(linux中无此错误可继续对同一套接字调用connect).
	5>. 对于放入已连接队列的socket,在select返回和accept函数调用之间连接终止的话,有些系统accept返回错误,有些系统accept将阻塞直到其他某个连接建立成功(对于这种须在accept之前将套接字设置为非阻塞模式以避免无法处理其他描述符的就绪事件).

第十七章:ioctl操作
	1>. ioctl函数是个杂物箱,为不适合归入其他精细定义的功能提供系统接口.
		ioctl函数提供的网络相关请求分为6类:套接字操作,文件操作,接口操作,ARP高速缓存操作,路由表操作,流操作.
	2>. 套接字操作包含:判断是否位于外带标记,设置或获取套接字进程ID(i.e. 接收SIGIO和SIGURG信号的进程).
	3>. 文件操作包含:设置或清除非阻塞IO,设置或清除信号驱动异步IO,获取接收缓冲区中的字节数,设置或获取文件的进程ID(和套接字操作的进程ID等效).
	4>. 接口操作包含:获取接口MTU,是否支持广播,设置获取广播地址,设置获取子网掩码,获取所有接口列表等.
	5>. ARP操作包含:增删改查ARP表项.
	6>. 路由表操作包含:增删路由表中的路径.

第十八章:路由套接字
	1>. 路由套接字(AF_ROUTE)为了操作内核中的路由子系统而创建,提供以下功能:
		1>.进程可以通过路由套接字读取内核信息,获取类似ICMP重定向等信息(tips 需root权限).
		2>.进程可以通过路由套接字发送消息给内核,用来增加或者删除路径(tips 需root权限).
		3>.进程可以通过sysctl倾泻路由表或列出所有已配置的接口.
	2>. 由于内核是根据应用程序写入的消息来完成对路由信息的输出或修改的,路由套接字发送和读取的数据是有固定格式的(5种结构体).
	3>. sysctl函数用于获取和设置系统信息(系统参数),这些系统信息分为8个一级子系统(e.g. 硬件子系统,网络子系统,内核子系统,虚拟内存子系统等).
	4>. 调用sysctl函数指定参数为网络子系统->路由域,可替代路由套接字检查路由表和接口列表的功能.
		调用sysctl函数指定参数为网络子系统->IPv4域->UDP->CHECKSUM,可判断UDP是否开启校验和.

第十九章:密钥管理套接字
	1>. 密钥管理套接字(AF_KEY域)为了管理内核中的密钥,及秘钥管理守护进程等服务之间交换SA. 提供如下功能:
		1>.通过写入密钥管理套接字可以向内核和打开的密钥管理套接字的所有进程发送消息
		2>.通过读取密钥管理套接字,可以从内核或其他进程接收消息(e.g.,请求某个密钥管理守护成为依照策略需受保护的一个新TCP会话安装一个SA).
		3>.可以写入一个倾泻请求,内核应答倾泻出当前SADB.
	2>. 密钥管理套接字收发的数据都有相同的基本首部sadb_msg,根据sadb_msg_type成员确定是何种请求及后跟什么扩展.
		消息类型有:创建SADB表项,删除SADB表项,增加表项,获取表项,通知表项期满等等.

第二十章:广播
	1>. 单播:一对一传送数据.
		广播:传送给本地子网中所有主机.
		多播:也叫组播,仅传送给加入多播组的主机.
		网卡在接收数据时通常仅接收那些目的地址为网卡物理地址或广播地址的帧,若接收后就将它传往协议上一层.
	2>. 广播的用途之一是服务发现,另一个用途是在多个客户端与单个服务器通信的局域网中尽量减少分组流通.
		使用广播的例子:
			1>.ARP:ARP使用链路层广播,在本地子网上广播请求"IP地址为a.b.c.d的系统亮明身份,告诉我你的MAC地址"
			2>.DHCP:向广播地址(通常是255.255.255.255)发送请求分配自己的地址信息.
			3>.路由守护进程routed:在局域网广播自己的路由表,所有邻居路由器可以接收这些路由通告,而无需为每个路由器配置其邻居路由器的IP地址.
	3>. 多播(组播)支持在IPv4中是可选的,在IPv6中是必须支持的.
		广播和多播(组播)都要求使用UDP或原始IP,不能用于TCP.
		IPv6不支持广播,任何IPv4的广播程序升级到IPv6都必须使用多播(组播)重写.
	4>. {子网ID,主机ID}标识一个IPv4地址, 其中子网ID标识由子网掩码覆盖的连续位,主机ID标识没被覆盖的位.
	5>. 广播地址分为两种:
			1>.子网定向广播地址:{子网ID，-1}形式,子网ID表示由子网掩码覆盖的连续位,主机ID表示以外的位(-1表示所有位均为1的字段).
			2>.受限广播地址:受限广播地址:{-1,-1}形式(255.255.255.255).
	6>. UDP单播数据包发送和接收的过程:
			1>.udp套接字调用sendto往某一ip和端口发送一个数据包.
			2>.传输层udp对它冠以一个UDP首部传递到网络层.
			3>.网络层对它冠以一个IPv4首部传递到链路层.
			4>.链路层把目的IP映射成以太网地址(MAC地址)添加一个以太网首部,作为以太网帧发送出去.
			5>.子网内所有主机的以太网卡都能看到该以太网帧,然后比较该帧的目的以太网地址和自己的以太网地址是否一致
				●不一致则以太网卡忽略该以太网帧.
				●一致则读入整个帧并产生一个硬件中断,使网卡设备驱动程序从网卡内存读取该帧并传递到IP层.
			6>.IP层首先判断该数据分组的目的IP地址是本主机自己的IP地址之一则被接受,根据协议字段传递到UDP层.
			7>.UDP层检查数据报目的端口(如果套接字已连接还检查源端口),接着把该数据包置于相应套接字的接收队列.
		广播数据包发送和接收的步骤于UDP单播类似:
			1>.udp套接字调用sendto往某一广播地址(e.g.,192.168.42.255)和端口发送一个数据包.
			2>.主机注意到目的IP地址是所在以太网的子网定向广播地址时,把它映射成全1的以太网地址(ff:ff:ff:ff:ff:ff).
			3>.这个以太网地址使得子网内所有以太网卡都接收该帧,并根据类型传递到IP层(IPv4).
			4>.该数据分组的目的IP地址匹配接收主机的广播地址,然后根据协议字段传递到传输层(UDP层).
			5>.UDP层检查数据报目的端口,如果有打开相应端口的套接字则把数据报置于该套接字的接收队列,没有则丢弃该数据报(丢弃并不产生ICMP端口不可达消息,以避免广播风暴).
	7>. 应用程序无需为接收广播UDP数据报而进行任何特殊处理:只需创建一个UDP套接字,指定接收端口和IP地址(INADDR_ANY)即可.
		广播数据报也会递送给自己,这是广播的定义,广播分组去往子网上的所有主机包括发送主机自身.
	8>. FreeBSD和MacOS不允许对广播数据报分片,长度超过MTU将返回错误;linux允许对广播数据报分片.

第二十一章:多播
	1>. 单播地址标识单个接口,广播地址标识子网上的所有接口,多播地址标识一组接口;单播和广播是编址方案的两个极端,多播的目的就在于提供一种折衷的方案.
	2>. IPv4的D类地址是多播地址,从244.0.0.0到239.255.255.255是多播地址(D类地址的低28位构成了多播组ID,而整个32位地址则称为组地址).
		特殊IPv4多播地址:
			●224.0.0.1是一个所有主机组,子网上所有具有多播能力的主机必须在所有具有多播能力的接口上加入该组.
			●224.0.0.2是一个所有路由器组,所有多播路由器必须在所有具有多播能力的接口加入该组.
			●224.0.0.0到224.0.0.255之间的地址称为链路局部地址(用于保留低级拓扑发现和维护协议).
	3>. IPv6多播地址的高序字节值为ff,组地址的低序32位拷贝到以太网地址的低序32位,以太网的高序2字节值为33:33.
		特殊IPv6多播地址:
			●ff01::1,ff02::1是一个所有节点组(子网上的具有多播能力的所有主机必须在具有多播能力的所有接口上加入该组),类似于IPv4的224.0.0.1多播地址.
			●ff01::2,ff02::2,ff05::2是一个所有路由器组(所有子网上的多播路由器必须在具有多播能力的所有接口上加入该组),类似于IPv4的2244.0.0.2多播地址.
	4>. IPv6多播地址显式存在一个4位的范围字段,用于指定多播数据报能够游走的范围;如果IPv6多播地址只是范围字段值不同则代表是不同的组.
		IPv4多播地址没有单独的范围字段,采用IPv4首部中的TTL字段兼用做多播范围字段.
		IPv6首部还有一个跳限字段,用于限制分组被路由器转发的次数.
	5>. 局域网IPv4多播发送接收数据过程:
			1>.接收多播数据报的进程:
				1>.创建UDP套接字.
				2>.绑定套接字到一个端口上.
				3>.然后加入多播组(e.g. 224.0.1.1).
				4>.加入多播组通过调用setsockopt函数,告知数据链路层接收目的以太网地址为01:00:5e:00:01:01的以太网帧,目的以太网地址是多播组地址映射的.
			2>.发送多播数据报的进程:
				1>.创建UDP套接字.
				2>.往IP地址为224.0.1.1的指定端口上发送数据报.
				3>.发送进程把多播组地址转换成相应以太网目的地址,再发送承载数据报的以太网帧;该帧含有目的以太网地址(由网卡检查)和目的IP地址(由IP层检查).
			发送多播数据报无需任何特殊处理,不用为发送多播数据报而加入多播组.
	6>. 多播对广播的优势:
		多播数据报的以以太网帧传到不接受的主机,在数据链路层就被丢弃,因为没有加入多播组接口比对目的以太网地址就丢弃了.
		广播数据报传到不接收的主机的传输层,找不到打开相应端口的UDP套接字而被丢弃.
	7>. 广域网上多播通过多播路由协议,当多播路由器下的主机加入了多播组时,该主机想所有直联的多播路由器发送一个IGMP消息,告知本主机已加入哪个多播组,多播路由器随后使用多播路由协议交换这些信息,使每个多播路由器知道收到多播地址分组时该如何处理.
	8>. 广域网上多播难以部署:
		1>.多播路由协议在加入多播组时需要在所有多播路由器之间交换这些信息.
		2>.IPv4没有足够数量的多播地址分配给想用多播的应用系统,且没有全球性的多播地址分配机制.
	9>. 源特定多播(SSM)可以解决下列问题:
		1>.接收进程想多播路由器提供发送进程的源地址作为多播组加入操作的一部分.
		2>.把多播组标识从单纯的多播组地址细化为单播源地址和多播目的地址的组合,称为通道.
	10>.多播套接字选项:
		IP_ADD_MEMBERSHIP/IPV6_JOIN_GROUP/MCAST_JOIN_GROUP指定一个本地接口上加入一个不限源的多播组;一个给定套接字可以多次加入不同的多播地址,或在不同接口上加入同一个多播地址.
		IP_DROP_MEMBERSHIP/IPV6_LEAVE_GROUP/MCAST_LEAVE_GROUP离开指定的本地接口上不限源的多播组;如果不显式离开,在套接字关闭时组成员关系自动被清除(离开).
		IP_BLOCK_SOURCE/MCAST_BLOCK_SOURCE指定在本套接字上阻塞接收来自某个源的多播分组.
		IP_UNBLOCK_SOURCE/MCAST_UNBLOCK_SOURCE取消阻塞来自某个源的多播分组.
		IP_ADD_SOURCE_MEMBERSHIP/MCAST_JOIN_SOURCE_GROUP指定一个本地接口上加入一个特定源的多播组.
		IP_DROP_SOURCE_MEMBERSHIP/MCAST_LEAVE_SOURCE_GROUP离开特定源的多播组.

第二十二章:高级UDP套接字编程★★★
	1>. 当一个UDP数据报长度大于用户传入的接收缓冲区时,recvmsg在msghdr结构中的msg_flags成员上设置MSG_TRUNC标志;并非所有系统都是这种实现方式,还有三种可能情形:
			1>.丢掉超出的字节并给应用进程返回MSG_TRUNC标志(需使用recvmsg接口来接收这个标志).
			2>.直接丢弃超出的字节而不通知应用进程.
			3>.保留超出的字节并在随后这个套接口上的读操作中返回这些数据.
		既然内核对超过用户接收缓冲区的数据报存在不同实现,有一个有效的检测方法是:总是分配比应用进程允许接收的最大数据报还多一个字节的缓冲区,如果最后一个字节被填充,则认定是一个过长的数据报.
	2>. UDP的适用场景:
			1>.使用广播或者多播时,因为UDP支持广播或多播.
			2>.对于丢包不太敏感的应用,比如多媒体数据丢包通过插值弥补不会造成太大影响.
			3>.对于简单请求应答应用,可添加差错检测功能到UDP.
	3>. 给UDP增加可靠性需增加两个特性即可满足绝大多数场景:
			1>.超时和重传;用于处理丢失的数据报.
			2>.序列号;验证请求应答是否匹配.
	4>. RTT:客户端与服务器之间的往返时间.
		RTO:超时重传时间.
		SPT:客户端请求的服务器处理时间.
		客户端发送请求的时间点-客户端接收应答的时间点=RTT+SPT
	5>. 重传定时器期满的三种情况:
			1>.请求丢失.
			2>.第一次请求的应答丢失.
			3>.RTO太小(收到第一次请求的应答在RTO之外),此时会导致重传二义性问题(把第一次的应答当做第二次请求的应答来计算出错误的RTT).
	6>. karn算法用以解决重传二义性问题:
		1>.不能依据重传报文的ACK信息来更新RTT.
		2>.当进行RTO超时重传时候需要进行指数回退(即每重传一次就增大RTO,直到有未重传的包被确认才恢复RTO的增量).
		更好的方法是(RFC1323):为每个请求冠以一个服务器必须回射的序列号和时间戳,通过当前时间减去回射的时间戳计算出每个应答的RTT,此方法不再有任何二义性.
	7>. TCP RTT的计算:
		利用TCP时间戳选项来精确测量RTT.
		RTT = 收到ACK的时间 - ACK包的Timestamp选项回显的时间(被确认数据包带上去的Timestamp选项值).
	8>. IPv6允许为发送的数据报指定5条信息(辅助数据):
			1>.源IPv6地址;通常是由bind指定,用于确保发送应答时的源地址和客户端请求的目的地址是同一个,这是IPv4难以提供的特性.
				当作为辅助数据指定源IPv6地址时,如果指定的是IN6ADDR_ANY_INIT,如果套接字已经bind过则使用bind的地址,如果未bind过则由内核选择源地址.
				如果作为辅助数据指定源IPv6地址是个确定的地址,则本次发送使用的就是这个地址(也就是说如果bind过会覆盖bind绑定的地址).
			2>.外出接口索引(网卡索引);如果不指定就由内核选择外出接口.
			3>.外出跳限;覆盖系统默认的跳限值(默认255).
			4>.下一跳地址;
			5>.外出流通类型;
		IPv6允许为接收的分组返回4条信息(辅助数据):
			1>.目的IPv6地址;获取对端发送时指定的目的IPv6地址.
			2>.到达接口索引;接收数据的网络接口索引值.
			3>.到达跳限;需打开IPV6_RECVHOPLIMIT套接字选项,返回跳限数.
			4>.到达流通类别;
	9>. IPv6控制路径MTU的四个套接字选项:
			IPV6_USE_MIN_MTU选项:使用IPv6最小MTU(IPv6定义最小MTU1280字节).
			IPV6_RECVPATHMUT选项:接收路径MTU变动通知,由recvmsg返回变动后的路径MTU.
			IPV6_PATHMTU选项:返回某个已连接套接字的当前路径MTU.
			IPV6_DONTFRAG选项:关闭自动分片特性.

第二十三章:高级SCTP套接字编程
	1>. 支持多宿,一个端点的多个直接连接的网络获得额外的可靠性.
	2>. 可以消除头端阻塞,多流的支持.
	3>. 保持的有消息边界.
	4>. 提供无序可靠性.
	5>. 提供部分可靠性,可以指定生命周期,过期数据由传输层(SCTP)丢弃.
	6>. 提供了一到一式的接口从TCP移植到SCTP的简易手段.
	7>. SCTP提供的TCP的特性:消息确认,丢包重传,乱序重排,窗口式流控,慢启动,拥塞避免,选择性确认.
		不包含的2个TCP特性:半关闭状态,紧急数据;其实这两个特性都是作为TCP的缺点的补丁手段而存在的.
	8>. SCTP不如TCP的地方:有消息边界,大量短消息的传输效率及数据有效负载比例没有TCP高.

第二十四章:紧急数据(TCP外带数据)
	1>. 外带数据:也叫紧急数据,用于一端发生了重要的事情,需立即通知对端,而不会被已经在内核发送缓冲区的数据所阻塞.
	2>. 使用send(fd,"a",1,MSG_OOB)发送一个字节的外带数据,经历如下过程:
			1>.TCP把这个数据放置在发送缓冲区的下一个可用位置,把这个字节标记为"OOB".
			2>.把紧急指针设置成再下一个位置.
			3>.对缓冲区中的数据组建一个分节,在TCP首部中设置URG标志,并把紧急偏移字段设置为指向外带数据之后的字节.
				这个分节可能不含标记为OOB的那个字节(OOB字节是否发送取决于OOB字节之前待发送字节长度,当前准备发送给对端的分节大小,对端通告的当前窗口大小).
			4>.即使TCP发送端因流量控制而暂停发送数据,紧急通知照样不伴随任何数据的发送.
			发送多个字节的外带数据,把最后一个字节标记为OOB,且紧急指针指向最后一字节之后的字节(下一个可用位置).
	3>. 接收外带数据的过程:
			1>.收到一个设置了URG标志的分节时,检查TCP紧急指针以确定本分节是不是首个到达的同一紧急字节的紧急模式分节,同一紧急字节的多个分组只有第一个分组到达通知接收进程由新的外带数据.
				上边有点绕口, i.e.,同一紧急字节的紧急通知可能有多个分节,其中一些分节可能不含紧急数据,由于流控等因素只是通知.
			2>.当有新的紧急指针到达,无论紧急指针指向的实际数据字节是否到达接收端,有两种通知方式就会被触发:
				●内核给接收套接字属主的进程发送SIGURG信号(需要调用fcntl/ioctl这么设置过).
				●IO多路复用的调用中产生异常条件返回.
			3>.当实际紧急字节到达接收端,紧急字节有两种存放方式(可由SO_OOBINLINE套接字选项控制):
				●该字节既可能被拉出带外(默认是拉出带外放入该套接字的一个独立的单字节缓冲区),只能通过指定MSG_OOB标志调用recv/recvfrom/recvmsg接收这个紧急字节.
				●也可能被留在带内(紧急字节在正常的接收缓冲区内),接收进程不能通过指定MSG_OOB的方式读取,只能通过检查该套接字的外带标记以获知何时读取这个字节.
			如果有多个OOB标记的字节,如果新OOB字节在旧OOB字节读取之前就到达,则就OOB字节会被丢弃.
	4>. 外带数据收发过程中注意事项:
		1>.对端尚未发送任何外带数据,通过指定MSG_OOB的读取操作将返回错误.
		2>.接收进程被告知对端已经发送了外带标记的分节,但紧急字节尚未到达时读入操作将返回EWOULDBLOCK错误.此时接收进程能做的仅仅是从接收缓冲区读取数据,以便腾出空间允许对端发送那个外带字节.
		3>.如果套接字设置了SO_OOBINLINE选项,后来试图通过指定MSG_OOB读取外带数据将返回错误.
	5>. sockatmark函数用于判断下一个待读取的字节是否是外带数据,是则返回1.
		读操作总是停在外带标记上(e.g,接收缓冲区中有100字节,而紧急字节在第6个字节上,应用进程执行一个请求100字节的read,那么读取操作返回的只有紧急数据之前的5个字节,从而使得进程能够调用sockatmark检测外带数据).

第二十五章:信号驱动式IO
	1>. 信号驱动式IO是用户进程预先告知内核,当某个描述符上发生某事时,内核使用信号通知相关进程.
	2>. 启动信号驱动式IO须执行3个步骤:
			1>.建立SIGIO的信号处理函数.
			2>.调用fcntl指定F_SETOWN设置套接字属主.
			3>.调用fcntl指定O_ASYNC开启套接字信号驱动式IO.
	3>. 要确定哪些条件导致内核产生信号取决于协议:
		UDP产生信号的条件有:
			●数据报到达套接字.
			●套接字发生错误.
		TCP产生信号的条件有:
			●连接请求已完成.
			●某个断开连接已发起.
			●某个断开连接已完成.
			●连接的某一半已关闭.
			●数据到达套接字.
			●数据已从缓冲区发走(发送缓冲区有空闲空间).
			●发生异步错误.
		TCP中内核发送SIGIO信号后,应用进程无法区分读写事件,须把套接字设置成非阻塞模式以防止read或write发生阻塞.

第二十六章:线程
	1>. 多进程的缺点:
		1>.即使有写时复制机制,fork依然是昂贵的.
		2>.fork后父子进程间需要进程间通信机制,复杂且费力.
	2>. 线程创建速度比进程快很多;同一进程内的线程共享同一地址空间,易于共享数据但带来了数据同步问题(进程间也有同步问题).
		每个线程都有各自的:线程ID, 栈指针, 栈, errno, 信号掩码, 优先级.
	3>. 线程不在累述(且没APUE详细全面),参见:
			APUE第十一章:线程
			APUE第十二章:线程控制

第二十七章:IP选项(IPv4/IPv6扩展首部)
	1>. IPv4允许在20字节首部固定部分之后跟以最多40个字节的选项(我觉着就是IPv4扩展头);有10种选项部分已废弃:
			1>.NOP选项:用途在无法4字节对齐时提供填充.
			2>.EOL选项:终止选项,作为IPv4选项结束的标志.
			3>.LSRR选项:宽松源路径选项.
			4>.SSRR选项:严格源路径选项.
			5>.Timestamp选项:时间戳.
			6>.Record route选项:
			7>.Router alert选项:
	2>. 通过getsockopt/setsockopt来读取和设置IP选项;对套接字设置IP选项之后,该套接字上发送的所有IP数据报都将包含这些选项.
		对由accept返回的已连接的TCP套接字调用getsockopt时,将返回客户端SYN分节所在IP数据报中可能出现的原路径选项的逆转(内核自动干的这事);如果SYN分节没有带选项,对这个套接字getsockopt调用返回的将是空.
		对于其他非accept返回的TCP套接字,所有UDP套接字和原始套接字,调用getsockopt返回的是调用setsockopt设置的IP选项的副本.		
	3>. 源路径选项是由IP数据报的发送者指定的一个IP地址列表.
		SSRR(严格源路径选项):数据报必须且只能逐一经过所列节点(i.e.列在源路径中的所有节点必须前后相邻).
		LSRR(宽松源路径选项):数据报必须逐一经过所列节点,不过也可以经过未列在源路径中的其他节点.
	4>. IPv6扩展首部有以下几种:
			1>.步跳选项:和下边的目的地址选项通常作为辅助数据通过sendmsg指定,并由recvmsg调用作为辅助数据返回.
			2>.目的地址选项.
			3>.源路径选项:类似于IPv4的原路径选项.
			4>.分片首部:由执行分片的主机产生然后在重组片时处理.
			5>.认证首部.
			6>.安全净荷封装.

第二十八章:原始套接字
	1>. 原始套接字提供普通TCP和UDP套接字不提供的三个能力:
			1>.原始套接字可以读写ICMP,IGMP分组(ping程序就是使用原始套接字),使用户进程可以访问底层协议而不必往内核添加往外代码.
			2>.原始套接字可以读写内核不处理的协议字段,还可以构造属于自己的平行于TCP/UDP的数据协议.
			3>.原始套接字通过使用IP_HDRINCL套接字选项自行构造IPv4首部.
		原始套接字是用户进程绕过传输层直接到达IP层使用IPv4或IPv6.
	2>. 创建原始套接字的步骤:
			1>.(必须root用户)调用socket函数并把第二个参数指定为SOCK_RAW,创建出一个原始套接字.
			2>.可以调用bind函数仅仅绑定本地地址,因为原始套接字没有端口的概念.
			3>.也可以调用connect函数仅仅设置目的地址,同样因为原始套接字没有端口的概念;调用connect之后就可以把sendto调用改为write或send了.
	3>. 原始套接字的发送规则:
			1>.未连接的通过sendto或sendmsg指定目的IP地址完成,已连接的直接调用send,write,writev完成发送.
			2>.如果IP_HDRINCL套接字选项未开启,那么内核会构造一个IP首部并把它置于用户进程发送的数据之前,IP首部的协议字段设置成socket函数的第三个参数.
			3>.如果IP_HDRINCL套接字选项已开启,那么用户进程发送的数据必须包含IP首部,整个IP首部由用户进程构造;不过IPv4标识字段可置为0从而告知内核设置该值,以及IPv4首部的校验和字段总是由内核计算并设置.
			4>.内核会对超出MTU的原始分组执行分片.
	4>. 原始套接字的IPv6与IPv4的差异:
			1>.IPv6原始套接字的发送和接收的协议首部中所有字段均采用网络字节序.
			2>.IPv6不存在IPV4的IP_HDRINCL套接字选项类似的东西,所以IPv6无法写入或读取完整的IPv6分组,但IPv6首部几乎所有字段及扩展首部都可以通过套接字选项或辅助数据来指定和获取.
				如果IPv6需要写入或读取完整的IPv6数据报就必须使用数据链路访问.
			3>.IPv6与IPv4原始套接字的校验和处理存在差异.
				IPv6原始套接字使用一个套接字选项告知内核是否计算并存储外出分组中的校验和,且验证接收分组中的校验和,默认是禁止的.
	5>. 原始套接字的接收规则:
			1>.接收到UDP和TCP分组绝不会传递到任何原始套接字(原始套接字无法截获它们),用户进程想读取UDP或TCP分组的IP数据包,必须在数据链路层读取这些分组.
			2>.大多数ICMP分组是在内核处理完后才传递到原始套接字的.
			3>.所有IGMP分组是在内核处理完后才传递到原始套接字的.
			4>.内核不认识其协议字段的所有IP数据包传递到原始套接字.
			5>.分片的数据包在重组完成之前不传递任何片段到原始套接字.
			6>.如果创建原始套接字时指定了非零的协议(socket函数第3个参数),接收数据报的套接字的协议字段必须匹配该值,否则该数据包不递送到该套接字.
			7>.如果原始套接字bind绑定了某个本地地址,则数据包目的地址必须匹配这个绑定的地址,否则不会递送到这个套接字.
			8>.如果原始桃姐子已connect指定了目的地址,则接收到数据报的源IP必须匹配这个已连接地址,否则不会递送到这个套接字.
		往IPv4原始套接字递送一个已收到数据报,递送过去的是包括IP首部在内的完整数据报, 而对于IPv6原始套接字递送到只是扣除了IPv6首部和扩展首部的负载.
	6>. ping程序:打开一个原始套接字,往某个IP地址发送一个ICMP回射请求,该节点则以一个ICMP回射应答相应,如果不可达则会收到一个目的地之或端口不可达的ICMP消息.
	7>. traceroute程序:允许我们确定IP数据报从本地主机游历到某个远程主机所经过的所有节点.
		traceroute原理:使用IPv4的TTL字段或IPv6的跳限字段以及两种ICMP消息;首先向目的地址发送一个TTL(或跳限)为1的UDP数据包,这个数据报导致第一跳路由器返送一个ICMP超限错误从而获取当前这一跳的地址,接着每递增TTL一次就发送一个数据报,逐步确定下一跳地址知道送达目的主机.

第二十九章:数据链路访问
	1>. 数据链路访问提供2个功能:
			1>.能够监视由数据链路层接收的分组,使得wireshark,tcpdump能够在普通主机上运行而无需专门的硬件;配合网络接口的混杂模式甚至能够监视本地电缆上流通的所有分组,而不仅仅是所在主机为目的的分组.
			2>.能够在用户空间直接读写数据链路层.
	2>. 原始套接字与数据链路访问的区别:
			1>.原始套接字直接访问的是网络层(IP层),通过原始套接字发的数据分组可以构造自己的IP首部,收的也没有IP首部只有IPv4负载部分(IPv6首部不能直接读写,但能通过套接字选型读写).
			2>.<数据链路层访问>直接访问的是数据链路层,通过BPF/DLPI/数据链路套接字可以读取完整的数据报,甚至包括以太包头,而且可以发送非IP数据报.
	3>. Unix上访问数据链路层的3个方法:
			1>.Berkeley分组过滤器BPF.
			2>.SVR4的数据链路提供者接口DLPI.
			3>.Linux的SOCK_PACKET数据链路套接字.
	4>. 伯克利分组过滤器:在支持BPF的系统上,每个数据链路驱动程序都在发送或接收一个分组时调用BPF,用于监视网络分组.
			●路局链路层在分组接收之后尽早调用BPF,以及在分组发送之前尽晚调用BPF,为了提供更精确的时间戳.
			●应用进程可以为每个打开的BPF设备装载各自的过滤器,过滤每个网络分组.
	5>. BPF使用3个技术来降低系统的开销:
			1>.应用进程安装的过滤器在内核中进程,以减少从BPF到用户空间的数据复制量.
			2>.由BPF传递到应用进程的只是每个分组的一段定长部分(大多数应用进程只需要分析分组的首部而不需要数据负载),同样减少了从BPF到用户空间的数据复制量.
			3>.BPF为每个应用进程分配各自的缓冲区,只有当缓冲区已满或读超时期满才复制数据到用户空间(读超时时长由应用进程指定).
	6>. 访问BPF的方式:
			1>.尝试打开设备/dev/bpf0,返回EBUSY错误就尝试打开下一个bpf1,如此递增尝试直到打开为止.
			2>.使用ioctl函数装载过滤器,设置读超时,设置缓冲区大小,关联到某个数据链路(i.e.网卡),开启混杂模式等.
			3>.read/write执行设备的IO操作.
	7>. DLPI接口:类似于伯克利分组过滤器,但相比BSD分组过滤器较弱,略...
	8>. Linux的数据链路套接字:
			1>.socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))创建套接字.
			2>.通过setsockopt设置套接字选项及指定网络接口(PACKET_ADD_MEMBERSHIP混杂模式,SO_ATTACH_FILTER过滤器).
			3>.send/recv/write/read来读写数据链路层.
	9>. Linux的数据链路套接字相比BSD的BPF有如下差别:
			1>.Linux的数据链路套接字不提供内核缓冲,虽有普通接收缓冲区但多个帧不能合并到一次读取操作中,从内核到用户空间复制数据的开销要高.
			2>.旧的数据链路套接字不提供过滤器设置选项,会接收所有以太分组(如果开启混杂模式还包括目的地址为别的主机的分组).
	10>.libpcap网络分组捕获函数库:目前只支持分组的读取不支持写入;tcpdump使用此函数库.
	11>.libnet分组构造与输出函数库:用于构造任意协议的分组并将其发送数据链路(网络接口).libnet隐藏了构造IP,UDP,TCP首部的许多细节,提供简单且便于移植的数据链路和原始套接字的发送接口.

第三十章:客户/服务器程序设计范式
	1>. accept调用是一个非原子操作,多线程访问需要加锁,使之只有一个线程等待连接.
	略.

第三十一章:流 略

附录A:IPv4,IPv6,ICMP★★★
	1>. IP层提供无连接不可靠的数据报递送服务,它把IP数据包地送到指定的目的地址,且不保证一定送达,不保证顺序到达,不保证只到达一次.
		IP层最重要的功能之一是路由.
	2>. IPv4首部:
			1>. 版本号.
			2>. 首部长度:包含20字节固定长度的IPv4首部和最多40字节的IP选项长度之和.
			3>. 服务码点:
			4>. 显式拥塞通知:
			5>. 总长度:整个IP数据报的长度.
			6>. 标识:用于IP层分片和重组.
			7>. DF位:指定不进行IP分片,可用于PMTU发现.
			8>. MF位:还有片段.
			9>. 片偏移:也用于分片和重组.
			10>.TTL存活时间:由转发他的路由减一,为0时丢弃.
			11>.协议:值有ICMP,IGMP,TCP,UDP.
			12>.首部校验和:此字段只对IP首部和选项进行计算,不包含IP数据报的负载.
			13>.源IPv4地址.
			14>.目的IPv4地址.
			15>.套接字选项(扩展首部).
	3>. IPv6首部:
			1>. 版本号.
			2>. 服务码点:
			3>. 显式拥塞通知:
			4>. 流标签:对某个套接字由应用进程指定或内核选取流标签,应用于该套接字发送的任何IPv6数据报,期望中间路由器对这些数据报进行特殊处理.
			5>. 净荷长度:40字节IPv6首部之后所有内容的长度(扩展首部也算在内,因此并非真正的净荷).
			6>. 下一首部:类似IPv4协议字段,值有ICMP,IGMP,TCP,UDP.
			7>. 跳限:类似IPv4首部的TTL,每经过一个路由器转发值减一,为0时丢弃.
			8>. 源IPv6地址.
			9>. 目的IPv6地址.
	4>. IPv4与IPv6首部的变化:
			1>.IPv6没有首部长度字段,因为IPv6没有选项固定为40字节;后可跟任意种类和数量的扩展首部,扩展首部有各自的长度字段.
			2>.IPv6首部本身64位对齐可加快64位体系结构上的处理.
			3>.IPv6没有分片字段,而用一个扩展首部用于分片.此设计决策是因为分片属于异常,异常情况不应该减慢正常处理.
			4>.IPv6首部没有校验和字段,因为上层协议(TCP,UDP)数据单元都有各自的校验和字段,使得转发IPv6分组的路由器在修改跳限字段后重新计算校验和,从而加快转发速度.
	5>. 从IPv4到IPv6的重要变化:
			1>.IPv6没有广播,可使用全节点多播组代替IPv4广播功能.
			2>.IPv6的分片只发生在IPv6数据报的源主机上,如果中间路由器对数据报不分片就无法转发,则总监路由器直接丢弃该分组.
			3>.IPv6要求支持路径MTU发现功能.
			4>.IPv6要求支持认证和安全选项,这是IPv6扩展首部.
	6>. IPv4地址:通常书写成点分十进制记法,分为单播地址,多播地址,试验地址3类.
		子网地址是一个32位网络地址和一个相应32位掩码构成;掩码中的值为1的位覆盖网络地址部分,值为0的位涵盖主机地址部分.
	7>. IPv6地址:通常书写成冒号分割的8个两字节(16位)的十六进制数,其中高序位隐含地址类型.
	8>. ICMP协议:通常用于在IP节点之间互通出错消息或信息性消息,主要包括:
			1>.目的地/网络/主机/协议/端口等等的不可达.
			2>.需分片但DF位已设置.
			3>.目的网络不可知.
			4>.目的网络由管理手段禁用.
			5>.回射请求(ping).
			6>.路由通告.
			7>.TTL或跳限值等于0了.
			8>.IP首部坏.
			9>.信息请求.

附录C:调试技术
	1>.ktrace/kdump工具.
		●ktrace用于跟踪一个进程的系统调用.
		●kdump用于把ktrace记录的系统调用输出到标准输出.
	2>.sock工具:从标准输入读取后通过TCP或UDP发送到指定地址;把接收到的数据输出到标准输出(TCP/UDP测试客户端).
	3>.tcpdump:网络抓包工具.
	4>.netstat:查看某一进程内的网络使用情况和状态.
	5>.lsof:列出打开的文件(包含网络套接字,覆盖netstat功能).
		由于lsof只报告打开的文件,因此无法报告处于TIME_WAIT状态的TCP端口(可通过netstat查看TIME_WAIT状态的TCP端口).
